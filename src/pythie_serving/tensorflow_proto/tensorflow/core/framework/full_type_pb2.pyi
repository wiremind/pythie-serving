"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _FullTypeId:
    ValueType = typing.NewType('ValueType', builtins.int)
    V: typing_extensions.TypeAlias = ValueType
class _FullTypeIdEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_FullTypeId.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    TFT_UNSET: _FullTypeId.ValueType  # 0
    """The default represents an uninitialized values."""

    TFT_VAR: _FullTypeId.ValueType  # 1
    """Type symbols. Used to construct more complex type expressions like
    algebraic data types.

    Type variables may serve as placeholder for any other type ID in type
    templates.

    Examples:
      TFT_DATASET[TFT_VAR["T"]] is a Dataset returning a type indicated by "T".
      TFT_TENSOR[TFT_VAR["T"]] is a Tensor of n element type indicated by "T".
      TFT_TENSOR[TFT_VAR["T"]], TFT_TENSOR[TFT_VAR["T"]] are two tensors of
        identical element types.
      TFT_TENSOR[TFT_VAR["P"]], TFT_TENSOR[TFT_VAR["Q"]] are two tensors of
        potentially different element types.
    """

    TFT_ANY: _FullTypeId.ValueType  # 2
    """Wildcard type. Describes a parameter of unknown type. In TensorFlow, that
    can mean either a "Top" type (accepts any type), or a dynamically typed
    object whose type is unknown in context.
    Important: "unknown" does not necessarily mean undeterminable!
    """

    TFT_PRODUCT: _FullTypeId.ValueType  # 3
    """The algebraic product type. This is an algebraic type that may be used just
    for logical grouping. Not to confused with TFT_TUPLE which describes a
    concrete object of several elements.

    Example:
      TFT_DATASET[TFT_PRODUCT[TFT_TENSOR[TFT_INT32], TFT_TENSOR[TFT_FLOAT64]]]
        is a Dataset producing two tensors, an integer one and a float one.
    """

    TFT_CALLABLE: _FullTypeId.ValueType  # 100
    """Callable types describe functions and ops.

    Parametrization:
      TFT_CALLABLE[<arg type>, <return type>]
      * <arg_type> is the type of the arguments; TFT_PRODUCT represents
      multiple
        arguments.
      * <return_type> is the return type; TFT_PRODUCT represents multiple
        return values (that means that callables returning multiple things
        don't necessarily return a single tuple).

    Example:
      TFT_CALLABLE[
        TFT_ANY,
        TFT_PRODUCT[TFT_TENSOR[TFT_INT32], TFT_TENSOR[TFT_FLOAT64]],
      ]
        is a callable with unspecified (for now) input arguments, and
        two return values of type tensor.
    """

    TFT_TENSOR: _FullTypeId.ValueType  # 1000
    """Concrete type IDs, representing "proper" data types that can describe
    runtime TensorFlow objects.

    The usual Tensor. This is a parametric type.

    Parametrization:
      TFT_TENSOR[<element type>, <shape type>]
      * <element_type> is currently limited to one of the element types
        defined below.
      * <shape_type> is not yet defined, and may only be TFT_UNKNOWN for now.

    A TFT_SHAPE type will be defined in the future.

    Example:
      TFT_TENSOR[TFT_INT32, TFT_UNKNOWN]
        is a Tensor of int32 element type and unknown shape.

    TODO(mdan): Define TFT_SHAPE and add more examples.
    """

    TFT_ARRAY: _FullTypeId.ValueType  # 1001
    """Array (or tensorflow::TensorList in the variant type registry).
    Note: this is not to be confused with the deprecated `TensorArray*` ops
    which are not supported by FullType.
    This type represents a random-access list whose elements can be
    described by a single type. Although immutable, Array is expected to
    support efficient mutation semantics (i.e. element update) in the
    user-facing API.
    The element type may be generic or even TFT_ANY for a heterogenous list.

    Parametrization:
      TFT_ARRAY[<element type>]
      * <element_type> may be any concrete type.

    Examples:
      TFT_ARRAY[TFT_TENSOR[TFT_INT32]] is a TensorArray holding int32 Tensors
        of any shape.
      TFT_ARRAY[TFT_TENSOR[TFT_UNKNOWN]] is a TensorArray holding Tensors of
        mixed element types.
      TFT_ARRAY[TFT_UNKNOWN] is a TensorArray holding any element type.
      TFT_ARRAY[] is equivalent to TFT_ARRAY[TFT_UNKNOWN].
      TFT_ARRAY[TFT_ARRAY[]] is an array or arrays (of unknown types).
    """

    TFT_OPTIONAL: _FullTypeId.ValueType  # 1002
    """Optional (or tensorflow::OptionalVariant in the variant type registry).
    This type represents a value that may either hold an element of a single
    specified type, or nothing at all.

    Parametrization:
      TFT_OPTIONAL[<element type>]
      * <element_type> may be any concrete type.

    Examples:
      TFT_OPTIONAL[TFT_TENSOR[TFT_INT32]] is an Optional holding an int32
        Tensor of any shape.
    """

    TFT_DATASET: _FullTypeId.ValueType  # 10102
    """Datasets created by tf.data ops and APIs. Datasets have generator/iterable
    semantics, that is, one can construct an iterator from them. Like
    Array, they are considered to return elements that can be described
    by a single type. Unlike Array, they do not support random access or
    mutation, and can potentially produce an infinite number of elements.
    A datasets can produce logical structures (e.g. multiple elements). This
    is expressed using TFT_PRODUCT.


    Parametrization: TFT_ARRAY[<element type>].
    <element_type> may be a concrete type or a type symbol. It represents the
      data type of the elements produced by the dataset.

    Examples:
      TFT_DATSET[TFT_TENSOR[TFT_INT32]] is a Dataset producing single int32
        Tensors of unknown shape.
      TFT_DATSET[TFT_PRODUCT[TFT_TENSOR[TFT_INT32], TFT_TENSOR[TFT_FLOAT32]] is
      a
        Dataset producing pairs of Tensors, one integer and one float.
    Note: The high ID number is to prepare for the eventuality that Datasets
    will be supported by user types in the future.
    """

    TFT_BOOL: _FullTypeId.ValueType  # 200
    """Type attributes. These always appear in the parametrization of a type,
    never alone. For example, there is no such thing as a "bool" TensorFlow
    object (for now).

    The bool element type.
    TODO(mdan): Quantized types, legacy representations (e.g. ref)
    """

    TFT_UINT8: _FullTypeId.ValueType  # 201
    """Integer element types."""

    TFT_UINT16: _FullTypeId.ValueType  # 202
    TFT_UINT32: _FullTypeId.ValueType  # 203
    TFT_UINT64: _FullTypeId.ValueType  # 204
    TFT_INT8: _FullTypeId.ValueType  # 205
    TFT_INT16: _FullTypeId.ValueType  # 206
    TFT_INT32: _FullTypeId.ValueType  # 207
    TFT_INT64: _FullTypeId.ValueType  # 208
    TFT_HALF: _FullTypeId.ValueType  # 209
    """Floating-point element types."""

    TFT_FLOAT: _FullTypeId.ValueType  # 210
    TFT_DOUBLE: _FullTypeId.ValueType  # 211
    TFT_BFLOAT16: _FullTypeId.ValueType  # 215
    TFT_COMPLEX64: _FullTypeId.ValueType  # 212
    """Complex element types.
    TODO(mdan): Represent as TFT_COMPLEX[TFT_DOUBLE] instead?
    """

    TFT_COMPLEX128: _FullTypeId.ValueType  # 213
    TFT_STRING: _FullTypeId.ValueType  # 214
    """The string element type."""

class FullTypeId(_FullTypeId, metaclass=_FullTypeIdEnumTypeWrapper):
    """Experimental. Represents the complete type information of a TensorFlow value."""
    pass

TFT_UNSET: FullTypeId.ValueType  # 0
"""The default represents an uninitialized values."""

TFT_VAR: FullTypeId.ValueType  # 1
"""Type symbols. Used to construct more complex type expressions like
algebraic data types.

Type variables may serve as placeholder for any other type ID in type
templates.

Examples:
  TFT_DATASET[TFT_VAR["T"]] is a Dataset returning a type indicated by "T".
  TFT_TENSOR[TFT_VAR["T"]] is a Tensor of n element type indicated by "T".
  TFT_TENSOR[TFT_VAR["T"]], TFT_TENSOR[TFT_VAR["T"]] are two tensors of
    identical element types.
  TFT_TENSOR[TFT_VAR["P"]], TFT_TENSOR[TFT_VAR["Q"]] are two tensors of
    potentially different element types.
"""

TFT_ANY: FullTypeId.ValueType  # 2
"""Wildcard type. Describes a parameter of unknown type. In TensorFlow, that
can mean either a "Top" type (accepts any type), or a dynamically typed
object whose type is unknown in context.
Important: "unknown" does not necessarily mean undeterminable!
"""

TFT_PRODUCT: FullTypeId.ValueType  # 3
"""The algebraic product type. This is an algebraic type that may be used just
for logical grouping. Not to confused with TFT_TUPLE which describes a
concrete object of several elements.

Example:
  TFT_DATASET[TFT_PRODUCT[TFT_TENSOR[TFT_INT32], TFT_TENSOR[TFT_FLOAT64]]]
    is a Dataset producing two tensors, an integer one and a float one.
"""

TFT_CALLABLE: FullTypeId.ValueType  # 100
"""Callable types describe functions and ops.

Parametrization:
  TFT_CALLABLE[<arg type>, <return type>]
  * <arg_type> is the type of the arguments; TFT_PRODUCT represents
  multiple
    arguments.
  * <return_type> is the return type; TFT_PRODUCT represents multiple
    return values (that means that callables returning multiple things
    don't necessarily return a single tuple).

Example:
  TFT_CALLABLE[
    TFT_ANY,
    TFT_PRODUCT[TFT_TENSOR[TFT_INT32], TFT_TENSOR[TFT_FLOAT64]],
  ]
    is a callable with unspecified (for now) input arguments, and
    two return values of type tensor.
"""

TFT_TENSOR: FullTypeId.ValueType  # 1000
"""Concrete type IDs, representing "proper" data types that can describe
runtime TensorFlow objects.

The usual Tensor. This is a parametric type.

Parametrization:
  TFT_TENSOR[<element type>, <shape type>]
  * <element_type> is currently limited to one of the element types
    defined below.
  * <shape_type> is not yet defined, and may only be TFT_UNKNOWN for now.

A TFT_SHAPE type will be defined in the future.

Example:
  TFT_TENSOR[TFT_INT32, TFT_UNKNOWN]
    is a Tensor of int32 element type and unknown shape.

TODO(mdan): Define TFT_SHAPE and add more examples.
"""

TFT_ARRAY: FullTypeId.ValueType  # 1001
"""Array (or tensorflow::TensorList in the variant type registry).
Note: this is not to be confused with the deprecated `TensorArray*` ops
which are not supported by FullType.
This type represents a random-access list whose elements can be
described by a single type. Although immutable, Array is expected to
support efficient mutation semantics (i.e. element update) in the
user-facing API.
The element type may be generic or even TFT_ANY for a heterogenous list.

Parametrization:
  TFT_ARRAY[<element type>]
  * <element_type> may be any concrete type.

Examples:
  TFT_ARRAY[TFT_TENSOR[TFT_INT32]] is a TensorArray holding int32 Tensors
    of any shape.
  TFT_ARRAY[TFT_TENSOR[TFT_UNKNOWN]] is a TensorArray holding Tensors of
    mixed element types.
  TFT_ARRAY[TFT_UNKNOWN] is a TensorArray holding any element type.
  TFT_ARRAY[] is equivalent to TFT_ARRAY[TFT_UNKNOWN].
  TFT_ARRAY[TFT_ARRAY[]] is an array or arrays (of unknown types).
"""

TFT_OPTIONAL: FullTypeId.ValueType  # 1002
"""Optional (or tensorflow::OptionalVariant in the variant type registry).
This type represents a value that may either hold an element of a single
specified type, or nothing at all.

Parametrization:
  TFT_OPTIONAL[<element type>]
  * <element_type> may be any concrete type.

Examples:
  TFT_OPTIONAL[TFT_TENSOR[TFT_INT32]] is an Optional holding an int32
    Tensor of any shape.
"""

TFT_DATASET: FullTypeId.ValueType  # 10102
"""Datasets created by tf.data ops and APIs. Datasets have generator/iterable
semantics, that is, one can construct an iterator from them. Like
Array, they are considered to return elements that can be described
by a single type. Unlike Array, they do not support random access or
mutation, and can potentially produce an infinite number of elements.
A datasets can produce logical structures (e.g. multiple elements). This
is expressed using TFT_PRODUCT.


Parametrization: TFT_ARRAY[<element type>].
<element_type> may be a concrete type or a type symbol. It represents the
  data type of the elements produced by the dataset.

Examples:
  TFT_DATSET[TFT_TENSOR[TFT_INT32]] is a Dataset producing single int32
    Tensors of unknown shape.
  TFT_DATSET[TFT_PRODUCT[TFT_TENSOR[TFT_INT32], TFT_TENSOR[TFT_FLOAT32]] is
  a
    Dataset producing pairs of Tensors, one integer and one float.
Note: The high ID number is to prepare for the eventuality that Datasets
will be supported by user types in the future.
"""

TFT_BOOL: FullTypeId.ValueType  # 200
"""Type attributes. These always appear in the parametrization of a type,
never alone. For example, there is no such thing as a "bool" TensorFlow
object (for now).

The bool element type.
TODO(mdan): Quantized types, legacy representations (e.g. ref)
"""

TFT_UINT8: FullTypeId.ValueType  # 201
"""Integer element types."""

TFT_UINT16: FullTypeId.ValueType  # 202
TFT_UINT32: FullTypeId.ValueType  # 203
TFT_UINT64: FullTypeId.ValueType  # 204
TFT_INT8: FullTypeId.ValueType  # 205
TFT_INT16: FullTypeId.ValueType  # 206
TFT_INT32: FullTypeId.ValueType  # 207
TFT_INT64: FullTypeId.ValueType  # 208
TFT_HALF: FullTypeId.ValueType  # 209
"""Floating-point element types."""

TFT_FLOAT: FullTypeId.ValueType  # 210
TFT_DOUBLE: FullTypeId.ValueType  # 211
TFT_BFLOAT16: FullTypeId.ValueType  # 215
TFT_COMPLEX64: FullTypeId.ValueType  # 212
"""Complex element types.
TODO(mdan): Represent as TFT_COMPLEX[TFT_DOUBLE] instead?
"""

TFT_COMPLEX128: FullTypeId.ValueType  # 213
TFT_STRING: FullTypeId.ValueType  # 214
"""The string element type."""

global___FullTypeId = FullTypeId


class FullTypeDef(google.protobuf.message.Message):
    """Highly experimental and very likely to change.
    This encoding uses tags instead of dedicated messages for regularity. In
    particular the encoding imposes no restrictions on what the parameters of any
    type should be, which in particular needs to be true for type symbols.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    TYPE_ID_FIELD_NUMBER: builtins.int
    ARGS_FIELD_NUMBER: builtins.int
    S_FIELD_NUMBER: builtins.int
    type_id: global___FullTypeId.ValueType
    """The principal type represented by this object. This may be a concrete type
    (Tensor, Dataset) a type variable (used for dependent types) a type
    symbol (Any, Union). See FullTypeId for details.
    """

    @property
    def args(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___FullTypeDef]: ...
    s: typing.Text
    def __init__(self,
        *,
        type_id: global___FullTypeId.ValueType = ...,
        args: typing.Optional[typing.Iterable[global___FullTypeDef]] = ...,
        s: typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["attr",b"attr","s",b"s"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["args",b"args","attr",b"attr","s",b"s","type_id",b"type_id"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["attr",b"attr"]) -> typing.Optional[typing_extensions.Literal["s"]]: ...
global___FullTypeDef = FullTypeDef
