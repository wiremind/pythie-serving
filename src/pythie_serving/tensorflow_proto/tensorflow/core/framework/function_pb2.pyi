"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import tensorflow.core.framework.attr_value_pb2
import tensorflow.core.framework.node_def_pb2
import tensorflow.core.framework.op_def_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class FunctionDefLibrary(google.protobuf.message.Message):
    """A library is a set of named functions."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    FUNCTION_FIELD_NUMBER: builtins.int
    GRADIENT_FIELD_NUMBER: builtins.int
    REGISTERED_GRADIENTS_FIELD_NUMBER: builtins.int
    @property
    def function(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___FunctionDef]: ...
    @property
    def gradient(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___GradientDef]: ...
    @property
    def registered_gradients(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___RegisteredGradient]: ...
    def __init__(self,
        *,
        function: typing.Optional[typing.Iterable[global___FunctionDef]] = ...,
        gradient: typing.Optional[typing.Iterable[global___GradientDef]] = ...,
        registered_gradients: typing.Optional[typing.Iterable[global___RegisteredGradient]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["function",b"function","gradient",b"gradient","registered_gradients",b"registered_gradients"]) -> None: ...
global___FunctionDefLibrary = FunctionDefLibrary

class FunctionDef(google.protobuf.message.Message):
    """A function can be instantiated when the runtime can bind every attr
    with a value. When a GraphDef has a call to a function, it must
    have binding for every attr defined in the signature.

    TODO(zhifengc):
      * device spec, etc.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class AttrEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text
        @property
        def value(self) -> tensorflow.core.framework.attr_value_pb2.AttrValue: ...
        def __init__(self,
            *,
            key: typing.Text = ...,
            value: typing.Optional[tensorflow.core.framework.attr_value_pb2.AttrValue] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["value",b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    class ArgAttrs(google.protobuf.message.Message):
        """Attributes for function arguments. These attributes are the same set of
        valid attributes as to _Arg nodes.
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        class AttrEntry(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor
            KEY_FIELD_NUMBER: builtins.int
            VALUE_FIELD_NUMBER: builtins.int
            key: typing.Text
            @property
            def value(self) -> tensorflow.core.framework.attr_value_pb2.AttrValue: ...
            def __init__(self,
                *,
                key: typing.Text = ...,
                value: typing.Optional[tensorflow.core.framework.attr_value_pb2.AttrValue] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["value",b"value"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

        ATTR_FIELD_NUMBER: builtins.int
        @property
        def attr(self) -> google.protobuf.internal.containers.MessageMap[typing.Text, tensorflow.core.framework.attr_value_pb2.AttrValue]: ...
        def __init__(self,
            *,
            attr: typing.Optional[typing.Mapping[typing.Text, tensorflow.core.framework.attr_value_pb2.AttrValue]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["attr",b"attr"]) -> None: ...

    class ArgAttrEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.int
        @property
        def value(self) -> global___FunctionDef.ArgAttrs: ...
        def __init__(self,
            *,
            key: builtins.int = ...,
            value: typing.Optional[global___FunctionDef.ArgAttrs] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["value",b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    class ResourceArgUniqueIdEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.int
        value: builtins.int
        def __init__(self,
            *,
            key: builtins.int = ...,
            value: builtins.int = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    class RetEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text
        value: typing.Text
        def __init__(self,
            *,
            key: typing.Text = ...,
            value: typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    class ControlRetEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text
        value: typing.Text
        def __init__(self,
            *,
            key: typing.Text = ...,
            value: typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    SIGNATURE_FIELD_NUMBER: builtins.int
    ATTR_FIELD_NUMBER: builtins.int
    ARG_ATTR_FIELD_NUMBER: builtins.int
    RESOURCE_ARG_UNIQUE_ID_FIELD_NUMBER: builtins.int
    NODE_DEF_FIELD_NUMBER: builtins.int
    RET_FIELD_NUMBER: builtins.int
    CONTROL_RET_FIELD_NUMBER: builtins.int
    @property
    def signature(self) -> tensorflow.core.framework.op_def_pb2.OpDef:
        """The definition of the function's name, arguments, return values,
        attrs etc.
        """
        pass
    @property
    def attr(self) -> google.protobuf.internal.containers.MessageMap[typing.Text, tensorflow.core.framework.attr_value_pb2.AttrValue]:
        """Attributes specific to this function definition."""
        pass
    @property
    def arg_attr(self) -> google.protobuf.internal.containers.MessageMap[builtins.int, global___FunctionDef.ArgAttrs]: ...
    @property
    def resource_arg_unique_id(self) -> google.protobuf.internal.containers.ScalarMap[builtins.int, builtins.int]:
        """Unique IDs for each resource argument, used to track aliasing resources. If
        Argument A and Argument B alias each other, then
        resource_arg_unique_ids[A.index] == resource_arg_unique_ids[B.index].

        If this field is empty, none of the arguments could alias; otherwise, every
        resource argument should have an entry in this field.

        When instantiated, the unique IDs will be attached to the _Arg nodes'
        "_resource_arg_unique_id" attribute.
        """
        pass
    @property
    def node_def(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[tensorflow.core.framework.node_def_pb2.NodeDef]:
        """In both of the following fields, there is the need to specify an
        output that is used as either the input to another node (in
        `node_def`) or as a return value of the function (in `ret`).
        Unlike the NodeDefs in GraphDef, we need to be able to specify a
        list in some cases (instead of just single outputs).  Also, we
        need to be able to deal with lists of unknown length (so the
        output index may not be known at function definition time).  So
        we use the following format instead:
        * "fun_in" where "fun_in" is the name of a function input arg in
          the `signature` field above.  This represents that input, whether
          it is a single tensor or a list.
        * "fun_in:0" gives the first element of a function input arg (a
          non-list input is considered a list of length 1 for these
          purposes).
        * "node:out" where "node" is the name of a node in `node_def` and
          "out" is the name one of its op's output arguments (the name
          comes from the OpDef of the node's op). This represents that
          node's output, whether it is a single tensor or a list.
          Note: We enforce that an op's output arguments are never
          renamed in the backwards-compatibility test.
        * "node:out:0" gives the first element of a node output arg (a
          non-list output is considered a list of length 1 for these
          purposes).

        NOT CURRENTLY SUPPORTED (but may be in the future):
        * "node:out:-1" gives last element in a node output list
        * "node:out:1:" gives a list with all but the first element in a
          node output list
        * "node:out::-1" gives a list with all but the last element in a
          node output list

        The body of the function.  Unlike the NodeDefs in a GraphDef, attrs
        may have values of type `placeholder` and the `input` field uses
        the "output" format above.

        By convention, "op" in node_def is resolved by consulting with a
        user-defined library first. If not resolved, "func" is assumed to
        be a builtin op.
        """
        pass
    @property
    def ret(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """A mapping from the output arg names from `signature` to the
        outputs from `node_def` that should be returned by the function.
        """
        pass
    @property
    def control_ret(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """A mapping from control output names from `signature` to node names in
        `node_def` which should be control outputs of this function.
        """
        pass
    def __init__(self,
        *,
        signature: typing.Optional[tensorflow.core.framework.op_def_pb2.OpDef] = ...,
        attr: typing.Optional[typing.Mapping[typing.Text, tensorflow.core.framework.attr_value_pb2.AttrValue]] = ...,
        arg_attr: typing.Optional[typing.Mapping[builtins.int, global___FunctionDef.ArgAttrs]] = ...,
        resource_arg_unique_id: typing.Optional[typing.Mapping[builtins.int, builtins.int]] = ...,
        node_def: typing.Optional[typing.Iterable[tensorflow.core.framework.node_def_pb2.NodeDef]] = ...,
        ret: typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        control_ret: typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["signature",b"signature"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["arg_attr",b"arg_attr","attr",b"attr","control_ret",b"control_ret","node_def",b"node_def","resource_arg_unique_id",b"resource_arg_unique_id","ret",b"ret","signature",b"signature"]) -> None: ...
global___FunctionDef = FunctionDef

class GradientDef(google.protobuf.message.Message):
    """GradientDef defines the gradient function of a function defined in
    a function library.

    A gradient function g (specified by gradient_func) for a function f
    (specified by function_name) must follow the following:

    The function 'f' must be a numerical function which takes N inputs
    and produces M outputs. Its gradient function 'g', which is a
    function taking N + M inputs and produces N outputs.

    I.e. if we have
       (y1, y2, ..., y_M) = f(x1, x2, ..., x_N),
    then, g is
       (dL/dx1, dL/dx2, ..., dL/dx_N) = g(x1, x2, ..., x_N,
                                         dL/dy1, dL/dy2, ..., dL/dy_M),
    where L is a scalar-value function of (x1, x2, ..., xN) (e.g., the
    loss function). dL/dx_i is the partial derivative of L with respect
    to x_i.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    FUNCTION_NAME_FIELD_NUMBER: builtins.int
    GRADIENT_FUNC_FIELD_NUMBER: builtins.int
    function_name: typing.Text
    """The function name."""

    gradient_func: typing.Text
    """The gradient function's name."""

    def __init__(self,
        *,
        function_name: typing.Text = ...,
        gradient_func: typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["function_name",b"function_name","gradient_func",b"gradient_func"]) -> None: ...
global___GradientDef = GradientDef

class RegisteredGradient(google.protobuf.message.Message):
    """RegisteredGradient stores a gradient function that is registered in the
    gradients library and used in the ops of a function in the function library.
    Unlike GradientDef, these gradients are identified by op type, and not
    directly linked to any function.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    GRADIENT_FUNC_FIELD_NUMBER: builtins.int
    REGISTERED_OP_TYPE_FIELD_NUMBER: builtins.int
    gradient_func: typing.Text
    """The gradient function's name."""

    registered_op_type: typing.Text
    """The gradient function's registered op type."""

    def __init__(self,
        *,
        gradient_func: typing.Text = ...,
        registered_op_type: typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["gradient_func",b"gradient_func","registered_op_type",b"registered_op_type"]) -> None: ...
global___RegisteredGradient = RegisteredGradient
