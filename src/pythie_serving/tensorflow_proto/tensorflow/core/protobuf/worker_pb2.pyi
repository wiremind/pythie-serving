"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
Copyright 2016 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================
"""
import builtins
import collections.abc
import google.protobuf.any_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import sys
import tensorflow.core.framework.cost_graph_pb2
import tensorflow.core.framework.device_attributes_pb2
import tensorflow.core.framework.graph_pb2
import tensorflow.core.framework.step_stats_pb2
import tensorflow.core.framework.tensor_pb2
import tensorflow.core.framework.tensor_shape_pb2
import tensorflow.core.framework.types_pb2
import tensorflow.core.protobuf.config_pb2
import tensorflow.core.protobuf.debug_pb2
import tensorflow.core.protobuf.named_tensor_pb2
import tensorflow.core.protobuf.tensorflow_server_pb2
import tensorflow.tsl.protobuf.error_codes_pb2

if sys.version_info >= (3, 8):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing_extensions.final
class GetStatusRequest(google.protobuf.message.Message):
    """//////////////////////////////////////////////////////////////////////////////

    GetStatus method request/response messages

    //////////////////////////////////////////////////////////////////////////////
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

global___GetStatusRequest = GetStatusRequest

@typing_extensions.final
class GetStatusResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DEVICE_ATTRIBUTES_FIELD_NUMBER: builtins.int
    @property
    def device_attributes(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[tensorflow.core.framework.device_attributes_pb2.DeviceAttributes]: ...
    def __init__(
        self,
        *,
        device_attributes: collections.abc.Iterable[tensorflow.core.framework.device_attributes_pb2.DeviceAttributes] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["device_attributes", b"device_attributes"]) -> None: ...

global___GetStatusResponse = GetStatusResponse

@typing_extensions.final
class CreateWorkerSessionRequest(google.protobuf.message.Message):
    """//////////////////////////////////////////////////////////////////////////////

    CreateSession method request/response messages

    For each session,

    //////////////////////////////////////////////////////////////////////////////
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SESSION_HANDLE_FIELD_NUMBER: builtins.int
    SERVER_DEF_FIELD_NUMBER: builtins.int
    ISOLATE_SESSION_STATE_FIELD_NUMBER: builtins.int
    CLUSTER_DEVICE_ATTRIBUTES_FIELD_NUMBER: builtins.int
    MASTER_TASK_FIELD_NUMBER: builtins.int
    MASTER_INCARNATION_FIELD_NUMBER: builtins.int
    session_handle: builtins.str
    """Sessions are identified by a given handle."""
    @property
    def server_def(self) -> tensorflow.core.protobuf.tensorflow_server_pb2.ServerDef:
        """Defines the configuration of a TensorFlow worker."""
    isolate_session_state: builtins.bool
    """If true, any resources such as Variables used in the session will not be
    shared with other sessions.
    """
    @property
    def cluster_device_attributes(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[tensorflow.core.framework.device_attributes_pb2.DeviceAttributes]:
        """The device attributes of all the devices in the cluster."""
    master_task: builtins.str
    """The master task name from which the request is sent."""
    master_incarnation: builtins.int
    """The incarnation ID of the master task local CPU device.
    If the target worker already has a WorkerSession created previously with
    the same master task name but a different incarnation, it usually indicates
    that the previous master failed before deleting the WorkerSession on the
    worker. To prevent memory leaks, the worker should garbage collect the old
    WorkerSessions.
    """
    def __init__(
        self,
        *,
        session_handle: builtins.str = ...,
        server_def: tensorflow.core.protobuf.tensorflow_server_pb2.ServerDef | None = ...,
        isolate_session_state: builtins.bool = ...,
        cluster_device_attributes: collections.abc.Iterable[tensorflow.core.framework.device_attributes_pb2.DeviceAttributes] | None = ...,
        master_task: builtins.str = ...,
        master_incarnation: builtins.int = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["server_def", b"server_def"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["cluster_device_attributes", b"cluster_device_attributes", "isolate_session_state", b"isolate_session_state", "master_incarnation", b"master_incarnation", "master_task", b"master_task", "server_def", b"server_def", "session_handle", b"session_handle"]) -> None: ...

global___CreateWorkerSessionRequest = CreateWorkerSessionRequest

@typing_extensions.final
class CreateWorkerSessionResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

global___CreateWorkerSessionResponse = CreateWorkerSessionResponse

@typing_extensions.final
class DeleteWorkerSessionRequest(google.protobuf.message.Message):
    """//////////////////////////////////////////////////////////////////////////////

    DeleteSession method request/response messages

    Deletes all worker-side state associated with the given session handle.

    //////////////////////////////////////////////////////////////////////////////
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SESSION_HANDLE_FIELD_NUMBER: builtins.int
    session_handle: builtins.str
    """Sessions are identified by a given handle."""
    def __init__(
        self,
        *,
        session_handle: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["session_handle", b"session_handle"]) -> None: ...

global___DeleteWorkerSessionRequest = DeleteWorkerSessionRequest

@typing_extensions.final
class DeleteWorkerSessionResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

global___DeleteWorkerSessionResponse = DeleteWorkerSessionResponse

@typing_extensions.final
class RegisterGraphRequest(google.protobuf.message.Message):
    """//////////////////////////////////////////////////////////////////////////////

    RegisterGraph method request/response messages

    For each session, after the master placed every node on a device,
    it partitions the whole graph into many subgraphs. All the nodes in
    a subgraph were in the same worker, but potentially on many devices
    owned by that worker (e.g. cpu0, plus gpu0, gpu1, ..., gpu7). The
    master registers subgraphs for a worker before running any steps. A
    successful registration returns a graph handle to be used in latter
    RunGraph requests.

    //////////////////////////////////////////////////////////////////////////////
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SESSION_HANDLE_FIELD_NUMBER: builtins.int
    CREATE_WORKER_SESSION_CALLED_FIELD_NUMBER: builtins.int
    GRAPH_DEF_FIELD_NUMBER: builtins.int
    HAS_CONTROL_FLOW_FIELD_NUMBER: builtins.int
    GRAPH_OPTIONS_FIELD_NUMBER: builtins.int
    DEBUG_OPTIONS_FIELD_NUMBER: builtins.int
    COLLECTIVE_GRAPH_KEY_FIELD_NUMBER: builtins.int
    CONFIG_PROTO_FIELD_NUMBER: builtins.int
    session_handle: builtins.str
    """Subgraphs are scoped within one session."""
    create_worker_session_called: builtins.bool
    """Set to true if `CreateWorkerSession` was called for `session_handle`."""
    @property
    def graph_def(self) -> tensorflow.core.framework.graph_pb2.GraphDef:
        """"graph_def" has the subgraph of nodes for this worker, with each node
        having its device_name filled in.
        """
    has_control_flow: builtins.bool
    """True iff the graph (before partitioning) contains control flow nodes.

    As of 01/11/2015, this is no longer set by clients.
    """
    @property
    def graph_options(self) -> tensorflow.core.protobuf.config_pb2.GraphOptions:
        """Configuration options for the session in which this graph was created."""
    @property
    def debug_options(self) -> tensorflow.core.protobuf.debug_pb2.DebugOptions:
        """Field(s) used by TensorFlow Debugger (tfdbg)."""
    collective_graph_key: builtins.int
    """If graph_def contains any collective ops this must be a positive
    integer used to coordinate execution with other graphs.  All
    graphs in a distributed execution with the same
    collective_graph_key will coordinate to use the same step_id
    concurrently so that BufRendezvous entries will make the correct
    values accessible.
    """
    @property
    def config_proto(self) -> tensorflow.core.protobuf.config_pb2.ConfigProto:
        """ConfigProto from the session in which this graph was created.
        Contains additional parameters beyond graph_options, including
        the name of the requested executor.
        """
    def __init__(
        self,
        *,
        session_handle: builtins.str = ...,
        create_worker_session_called: builtins.bool = ...,
        graph_def: tensorflow.core.framework.graph_pb2.GraphDef | None = ...,
        has_control_flow: builtins.bool = ...,
        graph_options: tensorflow.core.protobuf.config_pb2.GraphOptions | None = ...,
        debug_options: tensorflow.core.protobuf.debug_pb2.DebugOptions | None = ...,
        collective_graph_key: builtins.int = ...,
        config_proto: tensorflow.core.protobuf.config_pb2.ConfigProto | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["config_proto", b"config_proto", "debug_options", b"debug_options", "graph_def", b"graph_def", "graph_options", b"graph_options"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["collective_graph_key", b"collective_graph_key", "config_proto", b"config_proto", "create_worker_session_called", b"create_worker_session_called", "debug_options", b"debug_options", "graph_def", b"graph_def", "graph_options", b"graph_options", "has_control_flow", b"has_control_flow", "session_handle", b"session_handle"]) -> None: ...

global___RegisterGraphRequest = RegisterGraphRequest

@typing_extensions.final
class RegisterGraphResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    GRAPH_HANDLE_FIELD_NUMBER: builtins.int
    graph_handle: builtins.str
    """If the registration succeeds, returns an opaque graph_handle to
    the master. The master calls RunGraph with graph_handle to
    compute different steps.
    """
    def __init__(
        self,
        *,
        graph_handle: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["graph_handle", b"graph_handle"]) -> None: ...

global___RegisterGraphResponse = RegisterGraphResponse

@typing_extensions.final
class DeregisterGraphRequest(google.protobuf.message.Message):
    """//////////////////////////////////////////////////////////////////////////////

    DeregisterGraph method request/response messages

    The master deregisters the given graph_handle when the graph is no
    longer needed (e.g., the overall graph is re-scheduled and nodes
    are re-placed).

    The worker deregisters a graph_handle automatically according to on
    a TTL-base policy in case of master restarts.

    //////////////////////////////////////////////////////////////////////////////
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SESSION_HANDLE_FIELD_NUMBER: builtins.int
    CREATE_WORKER_SESSION_CALLED_FIELD_NUMBER: builtins.int
    GRAPH_HANDLE_FIELD_NUMBER: builtins.int
    session_handle: builtins.str
    """The session_handle used when registering the graph. If session_handle is
    empty, a single global namespace is used.
    """
    create_worker_session_called: builtins.bool
    """Set to true if `CreateWorkerSession` was called for `session_handle`."""
    graph_handle: builtins.str
    """REQUIRED: graph_handle must be returned by a RegisterGraph call
    to the same WorkerService.
    """
    def __init__(
        self,
        *,
        session_handle: builtins.str = ...,
        create_worker_session_called: builtins.bool = ...,
        graph_handle: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["create_worker_session_called", b"create_worker_session_called", "graph_handle", b"graph_handle", "session_handle", b"session_handle"]) -> None: ...

global___DeregisterGraphRequest = DeregisterGraphRequest

@typing_extensions.final
class DeregisterGraphResponse(google.protobuf.message.Message):
    """TODO(mrry): Optionally add summary stats for the graph."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

global___DeregisterGraphResponse = DeregisterGraphResponse

@typing_extensions.final
class CleanupAllRequest(google.protobuf.message.Message):
    """//////////////////////////////////////////////////////////////////////////////

    CleanupAll method request/response messages

    //////////////////////////////////////////////////////////////////////////////
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    CONTAINER_FIELD_NUMBER: builtins.int
    @property
    def container(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """A list of container names.

        If 'container' is not empty, releases resources in the given
        containers in all devices.

        If 'container' is empty, releases resources in the default
        container in all devices.
        """
    def __init__(
        self,
        *,
        container: collections.abc.Iterable[builtins.str] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["container", b"container"]) -> None: ...

global___CleanupAllRequest = CleanupAllRequest

@typing_extensions.final
class CleanupAllResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

global___CleanupAllResponse = CleanupAllResponse

@typing_extensions.final
class ExecutorOpts(google.protobuf.message.Message):
    """//////////////////////////////////////////////////////////////////////////////

    RunGraph request / response messages

    The worker executes all subgraphs registered under graph_handle.
    RunGraph returns after the execution finishes or an error is
    encountered.
    A sequence of RunGraphRequests with is_partial may be sent to RunGraph for
    partial graph execution.

    //////////////////////////////////////////////////////////////////////////////

    Options specific to the execution of a single step.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    RECORD_COSTS_FIELD_NUMBER: builtins.int
    RECORD_TIMELINE_FIELD_NUMBER: builtins.int
    RECORD_PARTITION_GRAPHS_FIELD_NUMBER: builtins.int
    REPORT_TENSOR_ALLOCATIONS_UPON_OOM_FIELD_NUMBER: builtins.int
    record_costs: builtins.bool
    record_timeline: builtins.bool
    record_partition_graphs: builtins.bool
    report_tensor_allocations_upon_oom: builtins.bool
    def __init__(
        self,
        *,
        record_costs: builtins.bool = ...,
        record_timeline: builtins.bool = ...,
        record_partition_graphs: builtins.bool = ...,
        report_tensor_allocations_upon_oom: builtins.bool = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["record_costs", b"record_costs", "record_partition_graphs", b"record_partition_graphs", "record_timeline", b"record_timeline", "report_tensor_allocations_upon_oom", b"report_tensor_allocations_upon_oom"]) -> None: ...

global___ExecutorOpts = ExecutorOpts

@typing_extensions.final
class RunGraphRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SESSION_HANDLE_FIELD_NUMBER: builtins.int
    CREATE_WORKER_SESSION_CALLED_FIELD_NUMBER: builtins.int
    GRAPH_HANDLE_FIELD_NUMBER: builtins.int
    STEP_ID_FIELD_NUMBER: builtins.int
    EXEC_OPTS_FIELD_NUMBER: builtins.int
    SEND_FIELD_NUMBER: builtins.int
    RECV_KEY_FIELD_NUMBER: builtins.int
    IS_PARTIAL_FIELD_NUMBER: builtins.int
    IS_LAST_PARTIAL_RUN_FIELD_NUMBER: builtins.int
    STORE_ERRORS_IN_RESPONSE_BODY_FIELD_NUMBER: builtins.int
    REQUEST_ID_FIELD_NUMBER: builtins.int
    session_handle: builtins.str
    """session_handle is the master-generated unique id for this session.
    If session_handle is non-empty, it must be the same as used when
    registering the graph. If it is empty, a single global namespace is used to
    search for the graph_handle.
    """
    create_worker_session_called: builtins.bool
    """Set to true if `CreateWorkerSession` was called for `session_handle`."""
    graph_handle: builtins.str
    """REQUIRED: graph_handle must be returned by a RegisterGraph call
    to the same WorkerService.
    """
    step_id: builtins.int
    """A unique ID to distinguish different runs of the same graph.

    The master generates a global unique `step_id` to distinguish
    different runs of the graph computation. Subgraphs communicate
    (e.g., send/recv ops) with each other using `step_id` to
    distinguish tensors generated by different runs.
    """
    @property
    def exec_opts(self) -> global___ExecutorOpts:
        """Options for this step."""
    @property
    def send(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[tensorflow.core.protobuf.named_tensor_pb2.NamedTensorProto]:
        """Runs the graph.

        Sends the tensors in "send" into the graph before the run and
        fetches the keys into `RunGraphResponse.recv` after the run.
        """
    @property
    def recv_key(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]: ...
    is_partial: builtins.bool
    """True if the RunGraphRequest is a partial run request."""
    is_last_partial_run: builtins.bool
    """True if this is the last partial run request in a sequence of requests."""
    store_errors_in_response_body: builtins.bool
    """If true then some errors, e.g., execution errors that have long
    error messages, may return an OK RunGraphResponse with the actual
    error saved in the status_code/status_error_message fields of the
    response body. This is a workaround since the RPC subsystem may
    truncate long metadata messages.
    """
    request_id: builtins.int
    """Unique identifier for this request. Every RunGraphRequest must have a
    unique request_id, and retried RunGraphRequests must have the same
    request_id. If request_id is zero, retry detection is disabled.

    Retried RunGraphRequests are problematic because they may issue a
    RecvTensor that will have no corresponding sender and will wait forever.
    Workers use request_ids to reject retried RunGraph requests instead of
    waiting forever.
    """
    def __init__(
        self,
        *,
        session_handle: builtins.str = ...,
        create_worker_session_called: builtins.bool = ...,
        graph_handle: builtins.str = ...,
        step_id: builtins.int = ...,
        exec_opts: global___ExecutorOpts | None = ...,
        send: collections.abc.Iterable[tensorflow.core.protobuf.named_tensor_pb2.NamedTensorProto] | None = ...,
        recv_key: collections.abc.Iterable[builtins.str] | None = ...,
        is_partial: builtins.bool = ...,
        is_last_partial_run: builtins.bool = ...,
        store_errors_in_response_body: builtins.bool = ...,
        request_id: builtins.int = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["exec_opts", b"exec_opts"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["create_worker_session_called", b"create_worker_session_called", "exec_opts", b"exec_opts", "graph_handle", b"graph_handle", "is_last_partial_run", b"is_last_partial_run", "is_partial", b"is_partial", "recv_key", b"recv_key", "request_id", b"request_id", "send", b"send", "session_handle", b"session_handle", "step_id", b"step_id", "store_errors_in_response_body", b"store_errors_in_response_body"]) -> None: ...

global___RunGraphRequest = RunGraphRequest

@typing_extensions.final
class RunGraphResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    RECV_FIELD_NUMBER: builtins.int
    STEP_STATS_FIELD_NUMBER: builtins.int
    COST_GRAPH_FIELD_NUMBER: builtins.int
    PARTITION_GRAPH_FIELD_NUMBER: builtins.int
    STATUS_CODE_FIELD_NUMBER: builtins.int
    STATUS_ERROR_MESSAGE_FIELD_NUMBER: builtins.int
    @property
    def recv(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[tensorflow.core.protobuf.named_tensor_pb2.NamedTensorProto]:
        """A list of tensors corresponding to those requested by
        `RunGraphRequest.recv_key`.
        """
    @property
    def step_stats(self) -> tensorflow.core.framework.step_stats_pb2.StepStats:
        """If the request asked for execution stats, the cost graph, or the partition
        graphs, these are returned here.
        TODO(suharshs): Package these in a RunMetadata instead.
        """
    @property
    def cost_graph(self) -> tensorflow.core.framework.cost_graph_pb2.CostGraphDef: ...
    @property
    def partition_graph(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[tensorflow.core.framework.graph_pb2.GraphDef]: ...
    status_code: tensorflow.tsl.protobuf.error_codes_pb2.Code.ValueType
    """If store_errors_in_response_body is true in the request, then
    optionally the server may return an OK status for the RPC and
    fill the true status into the fields below, to allow for messages
    that are too long to fit in metadata.
    """
    status_error_message: builtins.str
    def __init__(
        self,
        *,
        recv: collections.abc.Iterable[tensorflow.core.protobuf.named_tensor_pb2.NamedTensorProto] | None = ...,
        step_stats: tensorflow.core.framework.step_stats_pb2.StepStats | None = ...,
        cost_graph: tensorflow.core.framework.cost_graph_pb2.CostGraphDef | None = ...,
        partition_graph: collections.abc.Iterable[tensorflow.core.framework.graph_pb2.GraphDef] | None = ...,
        status_code: tensorflow.tsl.protobuf.error_codes_pb2.Code.ValueType = ...,
        status_error_message: builtins.str = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["cost_graph", b"cost_graph", "step_stats", b"step_stats"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["cost_graph", b"cost_graph", "partition_graph", b"partition_graph", "recv", b"recv", "status_code", b"status_code", "status_error_message", b"status_error_message", "step_stats", b"step_stats"]) -> None: ...

global___RunGraphResponse = RunGraphResponse

@typing_extensions.final
class CleanupGraphRequest(google.protobuf.message.Message):
    """//////////////////////////////////////////////////////////////////////////////

    CleanupGraph method request/response messages

    After the master receives RunGraph responses from all workers, the
    master instructs every worker to cleanup any remaining state of a
    step (e.g. tensors buffered by a `Send` op but not picked up by
    other workers). The master does not necessarily need to wait for
    completion of CleanupGraph calls.

    Workers should cleanup step states automatically according to a
    TTL-based policy in case of master restarts.

    //////////////////////////////////////////////////////////////////////////////
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    STEP_ID_FIELD_NUMBER: builtins.int
    step_id: builtins.int
    def __init__(
        self,
        *,
        step_id: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["step_id", b"step_id"]) -> None: ...

global___CleanupGraphRequest = CleanupGraphRequest

@typing_extensions.final
class CleanupGraphResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

global___CleanupGraphResponse = CleanupGraphResponse

@typing_extensions.final
class RecvTensorRequest(google.protobuf.message.Message):
    """//////////////////////////////////////////////////////////////////////////////

    RecvTensor method request/response messages

    //////////////////////////////////////////////////////////////////////////////
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    STEP_ID_FIELD_NUMBER: builtins.int
    RENDEZVOUS_KEY_FIELD_NUMBER: builtins.int
    DMA_OK_FIELD_NUMBER: builtins.int
    CLIENT_LOCALITY_FIELD_NUMBER: builtins.int
    SERVER_LOCALITY_FIELD_NUMBER: builtins.int
    TRANSPORT_OPTIONS_FIELD_NUMBER: builtins.int
    REQUEST_ID_FIELD_NUMBER: builtins.int
    step_id: builtins.int
    """The step in which the tensor will be produced.

    REQUIRED: This must eventually correspond to the `step_id` passed
    into a RunGraph call on the same WorkerService.
    """
    rendezvous_key: builtins.str
    """A key identifying the channel to receive tensors from. A RecvTensor request
    retrieves one tensor from the channel, but multiple tensors can be sent and
    received over the same channel with multiple RecvTensor requests. See
    rendezvous.h for details.
    """
    dma_ok: builtins.bool
    """If true, use an out-of-band DMA mechanism to transfer the
    received tensor.
    """
    @property
    def client_locality(self) -> tensorflow.core.framework.device_attributes_pb2.DeviceLocality:
        """Optional information on client-side device locality."""
    @property
    def server_locality(self) -> tensorflow.core.framework.device_attributes_pb2.DeviceLocality:
        """Optional information on server-side device locality."""
    @property
    def transport_options(self) -> google.protobuf.any_pb2.Any:
        """Optional information needed by the RPC subsystem."""
    request_id: builtins.int
    """Unique identifier for this request. Every RecvTensorRequest must have a
    unique request_id, and retried RecvTensorRequests must have the same
    request_id. If request_id is zero, retry detection and response cache
    are disabled.

    Retried RecvTensorRequests are problematic because a RecvTensor with no
    corresponding sender will wait forever, and the tensor may have been
    delivered to a previous retry. Workers use request_ids to reject retried
    RecvTensor requests instead of waiting forever.
    """
    def __init__(
        self,
        *,
        step_id: builtins.int = ...,
        rendezvous_key: builtins.str = ...,
        dma_ok: builtins.bool = ...,
        client_locality: tensorflow.core.framework.device_attributes_pb2.DeviceLocality | None = ...,
        server_locality: tensorflow.core.framework.device_attributes_pb2.DeviceLocality | None = ...,
        transport_options: google.protobuf.any_pb2.Any | None = ...,
        request_id: builtins.int = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["client_locality", b"client_locality", "server_locality", b"server_locality", "transport_options", b"transport_options"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["client_locality", b"client_locality", "dma_ok", b"dma_ok", "rendezvous_key", b"rendezvous_key", "request_id", b"request_id", "server_locality", b"server_locality", "step_id", b"step_id", "transport_options", b"transport_options"]) -> None: ...

global___RecvTensorRequest = RecvTensorRequest

@typing_extensions.final
class RecvTensorResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TENSOR_FIELD_NUMBER: builtins.int
    IS_DEAD_FIELD_NUMBER: builtins.int
    SEND_START_MICROS_FIELD_NUMBER: builtins.int
    TRANSPORT_OPTIONS_FIELD_NUMBER: builtins.int
    REQUIRE_ACK_FIELD_NUMBER: builtins.int
    @property
    def tensor(self) -> tensorflow.core.framework.tensor_pb2.TensorProto:
        """The tensor as a proto."""
    is_dead: builtins.bool
    """If true, this tensor was the output of a dead node, and the
    content is invalid.
    """
    send_start_micros: builtins.int
    """The time at which tensor was available and started to be returned."""
    @property
    def transport_options(self) -> google.protobuf.any_pb2.Any:
        """Optional additional information about how to receive the tensor,
        e.g. in the event that `RecvTensorRequest.dma_ok` was true.
        """
    require_ack: builtins.bool
    """Whether the receiver should send a MarkRecvFinishedRequest to the sender
    to ack the message.
    """
    def __init__(
        self,
        *,
        tensor: tensorflow.core.framework.tensor_pb2.TensorProto | None = ...,
        is_dead: builtins.bool = ...,
        send_start_micros: builtins.int = ...,
        transport_options: google.protobuf.any_pb2.Any | None = ...,
        require_ack: builtins.bool = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["tensor", b"tensor", "transport_options", b"transport_options"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["is_dead", b"is_dead", "require_ack", b"require_ack", "send_start_micros", b"send_start_micros", "tensor", b"tensor", "transport_options", b"transport_options"]) -> None: ...

global___RecvTensorResponse = RecvTensorResponse

@typing_extensions.final
class MarkRecvFinishedRequest(google.protobuf.message.Message):
    """Message for managing the response cache maintained on the sender side.
    Currently only used by the gRPC worker service.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    REQUEST_ID_FIELD_NUMBER: builtins.int
    request_id: builtins.int
    def __init__(
        self,
        *,
        request_id: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["request_id", b"request_id"]) -> None: ...

global___MarkRecvFinishedRequest = MarkRecvFinishedRequest

@typing_extensions.final
class MarkRecvFinishedResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

global___MarkRecvFinishedResponse = MarkRecvFinishedResponse

@typing_extensions.final
class LoggingRequest(google.protobuf.message.Message):
    """//////////////////////////////////////////////////////////////////////////////

    Logging method request/response messages

    NOTE(mrry): This feature is not supported in the open-source
    version, and these messages are expected to change.

    //////////////////////////////////////////////////////////////////////////////

    Out-of-band request to begin or end logging, or
    to retrieve logs for particular steps.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ENABLE_RPC_LOGGING_FIELD_NUMBER: builtins.int
    DISABLE_RPC_LOGGING_FIELD_NUMBER: builtins.int
    CLEAR_FIELD_NUMBER: builtins.int
    FETCH_STEP_ID_FIELD_NUMBER: builtins.int
    enable_rpc_logging: builtins.bool
    """If true, RPC logging will be enabled."""
    disable_rpc_logging: builtins.bool
    """If true, RPC logging will be disabled."""
    clear: builtins.bool
    """If true, discard any saved logging data (for all steps)."""
    @property
    def fetch_step_id(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """When set, requests all saved log data pertaining to the step.
        Any log data retrieved is eliminated from the store and cannot be
        retrieved again.
        """
    def __init__(
        self,
        *,
        enable_rpc_logging: builtins.bool = ...,
        disable_rpc_logging: builtins.bool = ...,
        clear: builtins.bool = ...,
        fetch_step_id: collections.abc.Iterable[builtins.int] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["clear", b"clear", "disable_rpc_logging", b"disable_rpc_logging", "enable_rpc_logging", b"enable_rpc_logging", "fetch_step_id", b"fetch_step_id"]) -> None: ...

global___LoggingRequest = LoggingRequest

@typing_extensions.final
class LabeledStepStats(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    STEP_ID_FIELD_NUMBER: builtins.int
    STEP_STATS_FIELD_NUMBER: builtins.int
    step_id: builtins.int
    @property
    def step_stats(self) -> tensorflow.core.framework.step_stats_pb2.StepStats: ...
    def __init__(
        self,
        *,
        step_id: builtins.int = ...,
        step_stats: tensorflow.core.framework.step_stats_pb2.StepStats | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["step_stats", b"step_stats"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["step_id", b"step_id", "step_stats", b"step_stats"]) -> None: ...

global___LabeledStepStats = LabeledStepStats

@typing_extensions.final
class LoggingResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    STEP_FIELD_NUMBER: builtins.int
    @property
    def step(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___LabeledStepStats]: ...
    def __init__(
        self,
        *,
        step: collections.abc.Iterable[global___LabeledStepStats] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["step", b"step"]) -> None: ...

global___LoggingResponse = LoggingResponse

@typing_extensions.final
class TraceOpts(google.protobuf.message.Message):
    """//////////////////////////////////////////////////////////////////////////////

    Tracing method request/response messages

    NOTE(mrry): This feature is not supported in the open-source
    version, and these messages are expected to change.

    //////////////////////////////////////////////////////////////////////////////
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DURATION_FIELD_NUMBER: builtins.int
    USE_STEP_PROFILER_FIELD_NUMBER: builtins.int
    USE_KERNEL_PROFILER_FIELD_NUMBER: builtins.int
    USE_EXTENDED_PROFILER_FIELD_NUMBER: builtins.int
    USE_GPU_PROFILER_FIELD_NUMBER: builtins.int
    USE_SAMPLE_PROFILER_FIELD_NUMBER: builtins.int
    duration: builtins.float
    """Length of the trace to be taken, in seconds."""
    use_step_profiler: builtins.bool
    """If true, capture step profile locally in each worker. Currently
    unimplemented.
    """
    use_kernel_profiler: builtins.bool
    """If true, capture kernel events from each worker."""
    use_extended_profiler: builtins.bool
    """If true, capture extended profiling events from TensorFlow process."""
    use_gpu_profiler: builtins.bool
    """If true, capture GPU profiling events locally on each
    machine. Currently unimplemented.
    """
    use_sample_profiler: builtins.bool
    """If true, collect sampled profile events. Currently unimplemented."""
    def __init__(
        self,
        *,
        duration: builtins.float = ...,
        use_step_profiler: builtins.bool = ...,
        use_kernel_profiler: builtins.bool = ...,
        use_extended_profiler: builtins.bool = ...,
        use_gpu_profiler: builtins.bool = ...,
        use_sample_profiler: builtins.bool = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["duration", b"duration", "use_extended_profiler", b"use_extended_profiler", "use_gpu_profiler", b"use_gpu_profiler", "use_kernel_profiler", b"use_kernel_profiler", "use_sample_profiler", b"use_sample_profiler", "use_step_profiler", b"use_step_profiler"]) -> None: ...

global___TraceOpts = TraceOpts

@typing_extensions.final
class TracingRequest(google.protobuf.message.Message):
    """Out-of-band request to configure distributed tracing."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    OPTIONS_FIELD_NUMBER: builtins.int
    @property
    def options(self) -> global___TraceOpts: ...
    def __init__(
        self,
        *,
        options: global___TraceOpts | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["options", b"options"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["options", b"options"]) -> None: ...

global___TracingRequest = TracingRequest

@typing_extensions.final
class TracingResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

global___TracingResponse = TracingResponse

@typing_extensions.final
class RecvBufRequest(google.protobuf.message.Message):
    """//////////////////////////////////////////////////////////////////////////////

    Raw data transfers in support of Collective Ops.
    These methods are experimental and subject to change.

    The intention is to allow collectives to take advantage of the most
    efficient methods available on a platform, e.g. RDMA, and not be
    constrained to use the RPC system in use by other methods.

    //////////////////////////////////////////////////////////////////////////////

    Use of the fields below may vary by implementation.  For example
    the buf_ptr and num_bytes may be set only for local operations and
    not sent on the wire, or only sent on the wire in one direction.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    STEP_ID_FIELD_NUMBER: builtins.int
    BUF_RENDEZVOUS_KEY_FIELD_NUMBER: builtins.int
    NUM_BYTES_FIELD_NUMBER: builtins.int
    BUF_PTR_FIELD_NUMBER: builtins.int
    CLIENT_LOCALITY_FIELD_NUMBER: builtins.int
    SERVER_LOCALITY_FIELD_NUMBER: builtins.int
    TRANSPORT_OPTIONS_FIELD_NUMBER: builtins.int
    SRC_DEVICE_FIELD_NUMBER: builtins.int
    DST_DEVICE_FIELD_NUMBER: builtins.int
    REQUEST_ID_FIELD_NUMBER: builtins.int
    SRC_INCARNATION_FIELD_NUMBER: builtins.int
    step_id: builtins.int
    """Used at server side to find the correct BufRendezvous."""
    buf_rendezvous_key: builtins.str
    """Arbitrary string identifying a BufRendezvous entry."""
    num_bytes: builtins.int
    """Size of value expected, must agree with BufRendezvous entry."""
    buf_ptr: builtins.int
    """When RDMA is in use, address of destination field on client."""
    @property
    def client_locality(self) -> tensorflow.core.framework.device_attributes_pb2.DeviceLocality:
        """Optional information on client-side device locality."""
    @property
    def server_locality(self) -> tensorflow.core.framework.device_attributes_pb2.DeviceLocality:
        """Optional information on server-side device locality."""
    @property
    def transport_options(self) -> google.protobuf.any_pb2.Any:
        """Optional, implementation-specific data."""
    src_device: builtins.str
    """For annotating timeline and device incarnation check."""
    dst_device: builtins.str
    """Optional, for annotating the timeline."""
    request_id: builtins.int
    """Depending on the RPC system in use, it may be necessary to set this
    id to detect resends of RPCs where the server is not aware that
    the prior RPC failed.
    """
    src_incarnation: builtins.int
    """Incarnation number of the source device, used to detect worker failures."""
    def __init__(
        self,
        *,
        step_id: builtins.int = ...,
        buf_rendezvous_key: builtins.str = ...,
        num_bytes: builtins.int = ...,
        buf_ptr: builtins.int = ...,
        client_locality: tensorflow.core.framework.device_attributes_pb2.DeviceLocality | None = ...,
        server_locality: tensorflow.core.framework.device_attributes_pb2.DeviceLocality | None = ...,
        transport_options: google.protobuf.any_pb2.Any | None = ...,
        src_device: builtins.str = ...,
        dst_device: builtins.str = ...,
        request_id: builtins.int = ...,
        src_incarnation: builtins.int = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["client_locality", b"client_locality", "server_locality", b"server_locality", "transport_options", b"transport_options"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["buf_ptr", b"buf_ptr", "buf_rendezvous_key", b"buf_rendezvous_key", "client_locality", b"client_locality", "dst_device", b"dst_device", "num_bytes", b"num_bytes", "request_id", b"request_id", "server_locality", b"server_locality", "src_device", b"src_device", "src_incarnation", b"src_incarnation", "step_id", b"step_id", "transport_options", b"transport_options"]) -> None: ...

global___RecvBufRequest = RecvBufRequest

@typing_extensions.final
class RecvBufResponse(google.protobuf.message.Message):
    """Use of the fields below may vary by implementation.  Comments give
    intended use.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    BUF_PTR_FIELD_NUMBER: builtins.int
    NUM_BYTES_FIELD_NUMBER: builtins.int
    IS_DEAD_FIELD_NUMBER: builtins.int
    TRANSPORT_OPTIONS_FIELD_NUMBER: builtins.int
    SEND_START_MICROS_FIELD_NUMBER: builtins.int
    REQUIRE_ACK_FIELD_NUMBER: builtins.int
    buf_ptr: builtins.int
    """Address of source field on server."""
    num_bytes: builtins.int
    """Byte length of buf_ptr field, if set."""
    is_dead: builtins.bool
    """True if value is 'dead' like a tensor."""
    @property
    def transport_options(self) -> google.protobuf.any_pb2.Any:
        """Optional, implementation-specific data."""
    send_start_micros: builtins.int
    """Optional, for timeline."""
    require_ack: builtins.bool
    """Whether the receiver should send a MarkRecvFinishedRequest to the sender
    to ack the message.
    """
    def __init__(
        self,
        *,
        buf_ptr: builtins.int = ...,
        num_bytes: builtins.int = ...,
        is_dead: builtins.bool = ...,
        transport_options: google.protobuf.any_pb2.Any | None = ...,
        send_start_micros: builtins.int = ...,
        require_ack: builtins.bool = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["transport_options", b"transport_options"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["buf_ptr", b"buf_ptr", "is_dead", b"is_dead", "num_bytes", b"num_bytes", "require_ack", b"require_ack", "send_start_micros", b"send_start_micros", "transport_options", b"transport_options"]) -> None: ...

global___RecvBufResponse = RecvBufResponse

@typing_extensions.final
class CompleteGroupRequest(google.protobuf.message.Message):
    """//////////////////////////////////////////////////////////////////////////////

    Collective Op dynamic group resolution messages.

    //////////////////////////////////////////////////////////////////////////////

    Supplies one or more device names as members of the group identified by
    group_key.  Service will respond when all group_size devices become known.
    All devices in group must have same type.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    GROUP_KEY_FIELD_NUMBER: builtins.int
    GROUP_SIZE_FIELD_NUMBER: builtins.int
    DEVICE_TYPE_FIELD_NUMBER: builtins.int
    COLLECTIVE_TYPE_FIELD_NUMBER: builtins.int
    DEVICE_ATTRIBUTES_FIELD_NUMBER: builtins.int
    group_key: builtins.int
    group_size: builtins.int
    device_type: builtins.str
    collective_type: builtins.int
    @property
    def device_attributes(self) -> tensorflow.core.framework.device_attributes_pb2.DeviceAttributes: ...
    def __init__(
        self,
        *,
        group_key: builtins.int = ...,
        group_size: builtins.int = ...,
        device_type: builtins.str = ...,
        collective_type: builtins.int = ...,
        device_attributes: tensorflow.core.framework.device_attributes_pb2.DeviceAttributes | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["device_attributes", b"device_attributes"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["collective_type", b"collective_type", "device_attributes", b"device_attributes", "device_type", b"device_type", "group_key", b"group_key", "group_size", b"group_size"]) -> None: ...

global___CompleteGroupRequest = CompleteGroupRequest

@typing_extensions.final
class CompleteGroupResponse(google.protobuf.message.Message):
    """Gives the complete membership of the group identified by group_key."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    GROUP_KEY_FIELD_NUMBER: builtins.int
    GROUP_SIZE_FIELD_NUMBER: builtins.int
    DEVICE_TYPE_FIELD_NUMBER: builtins.int
    NUM_TASKS_FIELD_NUMBER: builtins.int
    COMMUNICATOR_KEY_FIELD_NUMBER: builtins.int
    DEVICE_ATTRIBUTES_FIELD_NUMBER: builtins.int
    group_key: builtins.int
    group_size: builtins.int
    device_type: builtins.str
    num_tasks: builtins.int
    """number of distinct tasks hosting the devices"""
    communicator_key: builtins.bytes
    @property
    def device_attributes(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[tensorflow.core.framework.device_attributes_pb2.DeviceAttributes]: ...
    def __init__(
        self,
        *,
        group_key: builtins.int = ...,
        group_size: builtins.int = ...,
        device_type: builtins.str = ...,
        num_tasks: builtins.int = ...,
        communicator_key: builtins.bytes = ...,
        device_attributes: collections.abc.Iterable[tensorflow.core.framework.device_attributes_pb2.DeviceAttributes] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["communicator_key", b"communicator_key", "device_attributes", b"device_attributes", "device_type", b"device_type", "group_key", b"group_key", "group_size", b"group_size", "num_tasks", b"num_tasks"]) -> None: ...

global___CompleteGroupResponse = CompleteGroupResponse

@typing_extensions.final
class CompleteInstanceRequest(google.protobuf.message.Message):
    """Supplies data about one collective op belonging to the instance identified
    by instance_key.  Service will respond when all group_size ops have
    become known.  Most of the data being sent is for correctness checking,
    to ensure that all ops in the instance share common attributes.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAME_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    DATA_TYPE_FIELD_NUMBER: builtins.int
    SHAPE_FIELD_NUMBER: builtins.int
    GROUP_KEY_FIELD_NUMBER: builtins.int
    GROUP_SIZE_FIELD_NUMBER: builtins.int
    INSTANCE_KEY_FIELD_NUMBER: builtins.int
    DEVICE_TYPE_FIELD_NUMBER: builtins.int
    SUBDIV_OFFSET_FIELD_NUMBER: builtins.int
    DEVICE_FIELD_NUMBER: builtins.int
    IS_SOURCE_FIELD_NUMBER: builtins.int
    name: builtins.str
    type: builtins.int
    data_type: tensorflow.core.framework.types_pb2.DataType.ValueType
    @property
    def shape(self) -> tensorflow.core.framework.tensor_shape_pb2.TensorShapeProto: ...
    group_key: builtins.int
    group_size: builtins.int
    instance_key: builtins.int
    device_type: builtins.str
    @property
    def subdiv_offset(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]: ...
    device: builtins.str
    is_source: builtins.bool
    def __init__(
        self,
        *,
        name: builtins.str = ...,
        type: builtins.int = ...,
        data_type: tensorflow.core.framework.types_pb2.DataType.ValueType = ...,
        shape: tensorflow.core.framework.tensor_shape_pb2.TensorShapeProto | None = ...,
        group_key: builtins.int = ...,
        group_size: builtins.int = ...,
        instance_key: builtins.int = ...,
        device_type: builtins.str = ...,
        subdiv_offset: collections.abc.Iterable[builtins.int] | None = ...,
        device: builtins.str = ...,
        is_source: builtins.bool = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["shape", b"shape"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["data_type", b"data_type", "device", b"device", "device_type", b"device_type", "group_key", b"group_key", "group_size", b"group_size", "instance_key", b"instance_key", "is_source", b"is_source", "name", b"name", "shape", b"shape", "subdiv_offset", b"subdiv_offset", "type", b"type"]) -> None: ...

global___CompleteInstanceRequest = CompleteInstanceRequest

@typing_extensions.final
class CompleteInstanceResponse(google.protobuf.message.Message):
    """Confirms that every op in the instance has consistently declared itself.
    Also gives the source_rank in case of broadcast.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    INSTANCE_KEY_FIELD_NUMBER: builtins.int
    SOURCE_RANK_FIELD_NUMBER: builtins.int
    instance_key: builtins.int
    source_rank: builtins.int
    def __init__(
        self,
        *,
        instance_key: builtins.int = ...,
        source_rank: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["instance_key", b"instance_key", "source_rank", b"source_rank"]) -> None: ...

global___CompleteInstanceResponse = CompleteInstanceResponse

@typing_extensions.final
class GetStepSequenceRequest(google.protobuf.message.Message):
    """Request for next agreed-upon step_id for the specified graph_keys.
    This is used to enable multiple graphs containing nodes from
    a common collective instance to coordinate using the same step_ids.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    GRAPH_KEY_FIELD_NUMBER: builtins.int
    @property
    def graph_key(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]: ...
    def __init__(
        self,
        *,
        graph_key: collections.abc.Iterable[builtins.int] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["graph_key", b"graph_key"]) -> None: ...

global___GetStepSequenceRequest = GetStepSequenceRequest

@typing_extensions.final
class StepSequence(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    GRAPH_KEY_FIELD_NUMBER: builtins.int
    NEXT_STEP_ID_FIELD_NUMBER: builtins.int
    graph_key: builtins.int
    next_step_id: builtins.int
    def __init__(
        self,
        *,
        graph_key: builtins.int = ...,
        next_step_id: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["graph_key", b"graph_key", "next_step_id", b"next_step_id"]) -> None: ...

global___StepSequence = StepSequence

@typing_extensions.final
class GetStepSequenceResponse(google.protobuf.message.Message):
    """Next valid step_ids for one or more graph_keys."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    STEP_SEQUENCE_FIELD_NUMBER: builtins.int
    @property
    def step_sequence(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___StepSequence]: ...
    def __init__(
        self,
        *,
        step_sequence: collections.abc.Iterable[global___StepSequence] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["step_sequence", b"step_sequence"]) -> None: ...

global___GetStepSequenceResponse = GetStepSequenceResponse
