"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.any_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import tensorflow.core.framework.cost_graph_pb2
import tensorflow.core.framework.device_attributes_pb2
import tensorflow.core.framework.graph_pb2
import tensorflow.core.framework.step_stats_pb2
import tensorflow.core.framework.tensor_pb2
import tensorflow.core.framework.tensor_shape_pb2
import tensorflow.core.framework.types_pb2
import tensorflow.core.protobuf.config_pb2
import tensorflow.core.protobuf.debug_pb2
import tensorflow.core.protobuf.error_codes_pb2
import tensorflow.core.protobuf.named_tensor_pb2
import tensorflow.core.protobuf.tensorflow_server_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class GetStatusRequest(google.protobuf.message.Message):
    """//////////////////////////////////////////////////////////////////////////////

    GetStatus method request/response messages

    //////////////////////////////////////////////////////////////////////////////

    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    def __init__(self,
        ) -> None: ...
global___GetStatusRequest = GetStatusRequest

class GetStatusResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    DEVICE_ATTRIBUTES_FIELD_NUMBER: builtins.int
    @property
    def device_attributes(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[tensorflow.core.framework.device_attributes_pb2.DeviceAttributes]: ...
    def __init__(self,
        *,
        device_attributes: typing.Optional[typing.Iterable[tensorflow.core.framework.device_attributes_pb2.DeviceAttributes]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["device_attributes",b"device_attributes"]) -> None: ...
global___GetStatusResponse = GetStatusResponse

class CreateWorkerSessionRequest(google.protobuf.message.Message):
    """//////////////////////////////////////////////////////////////////////////////

    CreateSession method request/response messages

    For each session,

    //////////////////////////////////////////////////////////////////////////////

    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    SESSION_HANDLE_FIELD_NUMBER: builtins.int
    SERVER_DEF_FIELD_NUMBER: builtins.int
    ISOLATE_SESSION_STATE_FIELD_NUMBER: builtins.int
    CLUSTER_DEVICE_ATTRIBUTES_FIELD_NUMBER: builtins.int
    MASTER_TASK_FIELD_NUMBER: builtins.int
    MASTER_INCARNATION_FIELD_NUMBER: builtins.int
    session_handle: typing.Text
    """Sessions are identified by a given handle."""

    @property
    def server_def(self) -> tensorflow.core.protobuf.tensorflow_server_pb2.ServerDef:
        """Defines the configuration of a TensorFlow worker."""
        pass
    isolate_session_state: builtins.bool
    """If true, any resources such as Variables used in the session will not be
    shared with other sessions.
    """

    @property
    def cluster_device_attributes(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[tensorflow.core.framework.device_attributes_pb2.DeviceAttributes]:
        """The device attributes of all the devices in the cluster."""
        pass
    master_task: typing.Text
    """The master task name from which the request is sent."""

    master_incarnation: builtins.int
    """The incarnation ID of the master task local CPU device.
    If the target worker already has a WorkerSession created previously with
    the same master task name but a different incarnation, it usually indicates
    that the previous master failed before deleting the WorkerSession on the
    worker. To prevent memory leaks, the worker should garbage collect the old
    WorkerSessions.
    """

    def __init__(self,
        *,
        session_handle: typing.Text = ...,
        server_def: typing.Optional[tensorflow.core.protobuf.tensorflow_server_pb2.ServerDef] = ...,
        isolate_session_state: builtins.bool = ...,
        cluster_device_attributes: typing.Optional[typing.Iterable[tensorflow.core.framework.device_attributes_pb2.DeviceAttributes]] = ...,
        master_task: typing.Text = ...,
        master_incarnation: builtins.int = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["server_def",b"server_def"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["cluster_device_attributes",b"cluster_device_attributes","isolate_session_state",b"isolate_session_state","master_incarnation",b"master_incarnation","master_task",b"master_task","server_def",b"server_def","session_handle",b"session_handle"]) -> None: ...
global___CreateWorkerSessionRequest = CreateWorkerSessionRequest

class CreateWorkerSessionResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    def __init__(self,
        ) -> None: ...
global___CreateWorkerSessionResponse = CreateWorkerSessionResponse

class DeleteWorkerSessionRequest(google.protobuf.message.Message):
    """//////////////////////////////////////////////////////////////////////////////

    DeleteSession method request/response messages

    Deletes all worker-side state associated with the given session handle.

    //////////////////////////////////////////////////////////////////////////////

    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    SESSION_HANDLE_FIELD_NUMBER: builtins.int
    session_handle: typing.Text
    """Sessions are identified by a given handle."""

    def __init__(self,
        *,
        session_handle: typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["session_handle",b"session_handle"]) -> None: ...
global___DeleteWorkerSessionRequest = DeleteWorkerSessionRequest

class DeleteWorkerSessionResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    def __init__(self,
        ) -> None: ...
global___DeleteWorkerSessionResponse = DeleteWorkerSessionResponse

class RegisterGraphRequest(google.protobuf.message.Message):
    """//////////////////////////////////////////////////////////////////////////////

    RegisterGraph method request/response messages

    For each session, after the master placed every node on a device,
    it partitions the whole graph into many subgraphs. All the nodes in
    a subgraph were in the same worker, but potentially on many devices
    owned by that worker (e.g. cpu0, plus gpu0, gpu1, ..., gpu7). The
    master registers subgraphs for a worker before running any steps. A
    successful registration returns a graph handle to be used in latter
    RunGraph requests.

    //////////////////////////////////////////////////////////////////////////////

    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    SESSION_HANDLE_FIELD_NUMBER: builtins.int
    CREATE_WORKER_SESSION_CALLED_FIELD_NUMBER: builtins.int
    GRAPH_DEF_FIELD_NUMBER: builtins.int
    HAS_CONTROL_FLOW_FIELD_NUMBER: builtins.int
    GRAPH_OPTIONS_FIELD_NUMBER: builtins.int
    DEBUG_OPTIONS_FIELD_NUMBER: builtins.int
    COLLECTIVE_GRAPH_KEY_FIELD_NUMBER: builtins.int
    CONFIG_PROTO_FIELD_NUMBER: builtins.int
    session_handle: typing.Text
    """Subgraphs are scoped within one session."""

    create_worker_session_called: builtins.bool
    """Set to true if `CreateWorkerSession` was called for `session_handle`."""

    @property
    def graph_def(self) -> tensorflow.core.framework.graph_pb2.GraphDef:
        """"graph_def" has the subgraph of nodes for this worker, with each node
        having its device_name filled in.
        """
        pass
    has_control_flow: builtins.bool
    """True iff the graph (before partitioning) contains control flow nodes.

    As of 01/11/2015, this is no longer set by clients.
    """

    @property
    def graph_options(self) -> tensorflow.core.protobuf.config_pb2.GraphOptions:
        """Configuration options for the session in which this graph was created."""
        pass
    @property
    def debug_options(self) -> tensorflow.core.protobuf.debug_pb2.DebugOptions:
        """Field(s) used by TensorFlow Debugger (tfdbg)."""
        pass
    collective_graph_key: builtins.int
    """If graph_def contains any collective ops this must be a positive
    integer used to coordinate execution with other graphs.  All
    graphs in a distributed execution with the same
    collective_graph_key will coordinate to use the same step_id
    concurrently so that BufRendezvous entries will make the correct
    values accessible.
    """

    @property
    def config_proto(self) -> tensorflow.core.protobuf.config_pb2.ConfigProto:
        """ConfigProto from the session in which this graph was created.
        Contains additional parameters beyond graph_options, including
        the name of the requested executor.
        """
        pass
    def __init__(self,
        *,
        session_handle: typing.Text = ...,
        create_worker_session_called: builtins.bool = ...,
        graph_def: typing.Optional[tensorflow.core.framework.graph_pb2.GraphDef] = ...,
        has_control_flow: builtins.bool = ...,
        graph_options: typing.Optional[tensorflow.core.protobuf.config_pb2.GraphOptions] = ...,
        debug_options: typing.Optional[tensorflow.core.protobuf.debug_pb2.DebugOptions] = ...,
        collective_graph_key: builtins.int = ...,
        config_proto: typing.Optional[tensorflow.core.protobuf.config_pb2.ConfigProto] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["config_proto",b"config_proto","debug_options",b"debug_options","graph_def",b"graph_def","graph_options",b"graph_options"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["collective_graph_key",b"collective_graph_key","config_proto",b"config_proto","create_worker_session_called",b"create_worker_session_called","debug_options",b"debug_options","graph_def",b"graph_def","graph_options",b"graph_options","has_control_flow",b"has_control_flow","session_handle",b"session_handle"]) -> None: ...
global___RegisterGraphRequest = RegisterGraphRequest

class RegisterGraphResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    GRAPH_HANDLE_FIELD_NUMBER: builtins.int
    graph_handle: typing.Text
    """If the registration succeeds, returns an opaque graph_handle to
    the master. The master calls RunGraph with graph_handle to
    compute different steps.
    """

    def __init__(self,
        *,
        graph_handle: typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["graph_handle",b"graph_handle"]) -> None: ...
global___RegisterGraphResponse = RegisterGraphResponse

class DeregisterGraphRequest(google.protobuf.message.Message):
    """//////////////////////////////////////////////////////////////////////////////

    DeregisterGraph method request/response messages

    The master deregisters the given graph_handle when the graph is no
    longer needed (e.g., the overall graph is re-scheduled and nodes
    are re-placed).

    The worker deregisters a graph_handle automatically according to on
    a TTL-base policy in case of master restarts.

    //////////////////////////////////////////////////////////////////////////////

    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    SESSION_HANDLE_FIELD_NUMBER: builtins.int
    CREATE_WORKER_SESSION_CALLED_FIELD_NUMBER: builtins.int
    GRAPH_HANDLE_FIELD_NUMBER: builtins.int
    session_handle: typing.Text
    """The session_handle used when registering the graph. If session_handle is
    empty, a single global namespace is used.
    """

    create_worker_session_called: builtins.bool
    """Set to true if `CreateWorkerSession` was called for `session_handle`."""

    graph_handle: typing.Text
    """REQUIRED: graph_handle must be returned by a RegisterGraph call
    to the same WorkerService.
    """

    def __init__(self,
        *,
        session_handle: typing.Text = ...,
        create_worker_session_called: builtins.bool = ...,
        graph_handle: typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["create_worker_session_called",b"create_worker_session_called","graph_handle",b"graph_handle","session_handle",b"session_handle"]) -> None: ...
global___DeregisterGraphRequest = DeregisterGraphRequest

class DeregisterGraphResponse(google.protobuf.message.Message):
    """TODO(mrry): Optionally add summary stats for the graph."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    def __init__(self,
        ) -> None: ...
global___DeregisterGraphResponse = DeregisterGraphResponse

class CleanupAllRequest(google.protobuf.message.Message):
    """//////////////////////////////////////////////////////////////////////////////

    CleanupAll method request/response messages

    //////////////////////////////////////////////////////////////////////////////

    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    CONTAINER_FIELD_NUMBER: builtins.int
    @property
    def container(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """A list of container names.

        If 'container' is not empty, releases resources in the given
        containers in all devices.

        If 'container' is empty, releases resources in the default
        container in all devices.
        """
        pass
    def __init__(self,
        *,
        container: typing.Optional[typing.Iterable[typing.Text]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["container",b"container"]) -> None: ...
global___CleanupAllRequest = CleanupAllRequest

class CleanupAllResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    def __init__(self,
        ) -> None: ...
global___CleanupAllResponse = CleanupAllResponse

class ExecutorOpts(google.protobuf.message.Message):
    """//////////////////////////////////////////////////////////////////////////////

    RunGraph request / response messages

    The worker executes all subgraphs registered under graph_handle.
    RunGraph returns after the execution finishes or an error is
    encountered.
    A sequence of RunGraphRequests with is_partial may be sent to RunGraph for
    partial graph execution.

    //////////////////////////////////////////////////////////////////////////////

    Options specific to the execution of a single step.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    RECORD_COSTS_FIELD_NUMBER: builtins.int
    RECORD_TIMELINE_FIELD_NUMBER: builtins.int
    RECORD_PARTITION_GRAPHS_FIELD_NUMBER: builtins.int
    REPORT_TENSOR_ALLOCATIONS_UPON_OOM_FIELD_NUMBER: builtins.int
    record_costs: builtins.bool
    record_timeline: builtins.bool
    record_partition_graphs: builtins.bool
    report_tensor_allocations_upon_oom: builtins.bool
    def __init__(self,
        *,
        record_costs: builtins.bool = ...,
        record_timeline: builtins.bool = ...,
        record_partition_graphs: builtins.bool = ...,
        report_tensor_allocations_upon_oom: builtins.bool = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["record_costs",b"record_costs","record_partition_graphs",b"record_partition_graphs","record_timeline",b"record_timeline","report_tensor_allocations_upon_oom",b"report_tensor_allocations_upon_oom"]) -> None: ...
global___ExecutorOpts = ExecutorOpts

class RunGraphRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    SESSION_HANDLE_FIELD_NUMBER: builtins.int
    CREATE_WORKER_SESSION_CALLED_FIELD_NUMBER: builtins.int
    GRAPH_HANDLE_FIELD_NUMBER: builtins.int
    STEP_ID_FIELD_NUMBER: builtins.int
    EXEC_OPTS_FIELD_NUMBER: builtins.int
    SEND_FIELD_NUMBER: builtins.int
    RECV_KEY_FIELD_NUMBER: builtins.int
    IS_PARTIAL_FIELD_NUMBER: builtins.int
    IS_LAST_PARTIAL_RUN_FIELD_NUMBER: builtins.int
    STORE_ERRORS_IN_RESPONSE_BODY_FIELD_NUMBER: builtins.int
    REQUEST_ID_FIELD_NUMBER: builtins.int
    session_handle: typing.Text
    """session_handle is the master-generated unique id for this session.
    If session_handle is non-empty, it must be the same as used when
    registering the graph. If it is empty, a single global namespace is used to
    search for the graph_handle.
    """

    create_worker_session_called: builtins.bool
    """Set to true if `CreateWorkerSession` was called for `session_handle`."""

    graph_handle: typing.Text
    """REQUIRED: graph_handle must be returned by a RegisterGraph call
    to the same WorkerService.
    """

    step_id: builtins.int
    """A unique ID to distinguish different runs of the same graph.

    The master generates a global unique `step_id` to distinguish
    different runs of the graph computation. Subgraphs communicate
    (e.g., send/recv ops) with each other using `step_id` to
    distinguish tensors generated by different runs.
    """

    @property
    def exec_opts(self) -> global___ExecutorOpts:
        """Options for this step."""
        pass
    @property
    def send(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[tensorflow.core.protobuf.named_tensor_pb2.NamedTensorProto]:
        """Runs the graph.

        Sends the tensors in "send" into the graph before the run and
        fetches the keys into `RunGraphResponse.recv` after the run.
        """
        pass
    @property
    def recv_key(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]: ...
    is_partial: builtins.bool
    """True if the RunGraphRequest is a partial run request."""

    is_last_partial_run: builtins.bool
    """True if this is the last partial run request in a sequence of requests."""

    store_errors_in_response_body: builtins.bool
    """If true then some errors, e.g., execution errors that have long
    error messages, may return an OK RunGraphResponse with the actual
    error saved in the status_code/status_error_message fields of the
    response body. This is a workaround since the RPC subsystem may
    truncate long metadata messages.
    """

    request_id: builtins.int
    """Unique identifier for this request. Every RunGraphRequest must have a
    unique request_id, and retried RunGraphRequests must have the same
    request_id. If request_id is zero, retry detection is disabled.

    Retried RunGraphRequests are problematic because they may issue a
    RecvTensor that will have no corresponding sender and will wait forever.
    Workers use request_ids to reject retried RunGraph requests instead of
    waiting forever.
    """

    def __init__(self,
        *,
        session_handle: typing.Text = ...,
        create_worker_session_called: builtins.bool = ...,
        graph_handle: typing.Text = ...,
        step_id: builtins.int = ...,
        exec_opts: typing.Optional[global___ExecutorOpts] = ...,
        send: typing.Optional[typing.Iterable[tensorflow.core.protobuf.named_tensor_pb2.NamedTensorProto]] = ...,
        recv_key: typing.Optional[typing.Iterable[typing.Text]] = ...,
        is_partial: builtins.bool = ...,
        is_last_partial_run: builtins.bool = ...,
        store_errors_in_response_body: builtins.bool = ...,
        request_id: builtins.int = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["exec_opts",b"exec_opts"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["create_worker_session_called",b"create_worker_session_called","exec_opts",b"exec_opts","graph_handle",b"graph_handle","is_last_partial_run",b"is_last_partial_run","is_partial",b"is_partial","recv_key",b"recv_key","request_id",b"request_id","send",b"send","session_handle",b"session_handle","step_id",b"step_id","store_errors_in_response_body",b"store_errors_in_response_body"]) -> None: ...
global___RunGraphRequest = RunGraphRequest

class RunGraphResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    RECV_FIELD_NUMBER: builtins.int
    STEP_STATS_FIELD_NUMBER: builtins.int
    COST_GRAPH_FIELD_NUMBER: builtins.int
    PARTITION_GRAPH_FIELD_NUMBER: builtins.int
    STATUS_CODE_FIELD_NUMBER: builtins.int
    STATUS_ERROR_MESSAGE_FIELD_NUMBER: builtins.int
    @property
    def recv(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[tensorflow.core.protobuf.named_tensor_pb2.NamedTensorProto]:
        """A list of tensors corresponding to those requested by
        `RunGraphRequest.recv_key`.
        """
        pass
    @property
    def step_stats(self) -> tensorflow.core.framework.step_stats_pb2.StepStats:
        """If the request asked for execution stats, the cost graph, or the partition
        graphs, these are returned here.
        TODO(suharshs): Package these in a RunMetadata instead.
        """
        pass
    @property
    def cost_graph(self) -> tensorflow.core.framework.cost_graph_pb2.CostGraphDef: ...
    @property
    def partition_graph(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[tensorflow.core.framework.graph_pb2.GraphDef]: ...
    status_code: tensorflow.core.protobuf.error_codes_pb2.Code.ValueType
    """If store_errors_in_response_body is true in the request, then
    optionally the server may return an OK status for the RPC and
    fill the true status into the fields below, to allow for messages
    that are too long to fit in metadata.
    """

    status_error_message: typing.Text
    def __init__(self,
        *,
        recv: typing.Optional[typing.Iterable[tensorflow.core.protobuf.named_tensor_pb2.NamedTensorProto]] = ...,
        step_stats: typing.Optional[tensorflow.core.framework.step_stats_pb2.StepStats] = ...,
        cost_graph: typing.Optional[tensorflow.core.framework.cost_graph_pb2.CostGraphDef] = ...,
        partition_graph: typing.Optional[typing.Iterable[tensorflow.core.framework.graph_pb2.GraphDef]] = ...,
        status_code: tensorflow.core.protobuf.error_codes_pb2.Code.ValueType = ...,
        status_error_message: typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["cost_graph",b"cost_graph","step_stats",b"step_stats"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["cost_graph",b"cost_graph","partition_graph",b"partition_graph","recv",b"recv","status_code",b"status_code","status_error_message",b"status_error_message","step_stats",b"step_stats"]) -> None: ...
global___RunGraphResponse = RunGraphResponse

class CleanupGraphRequest(google.protobuf.message.Message):
    """//////////////////////////////////////////////////////////////////////////////

    CleanupGraph method request/response messages

    After the master receives RunGraph responses from all workers, the
    master instructs every worker to cleanup any remaining state of a
    step (e.g. tensors buffered by a `Send` op but not picked up by
    other workers). The master does not necessarily need to wait for
    completion of CleanupGraph calls.

    Workers should cleanup step states automatically according to a
    TTL-based policy in case of master restarts.

    //////////////////////////////////////////////////////////////////////////////

    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    STEP_ID_FIELD_NUMBER: builtins.int
    step_id: builtins.int
    def __init__(self,
        *,
        step_id: builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["step_id",b"step_id"]) -> None: ...
global___CleanupGraphRequest = CleanupGraphRequest

class CleanupGraphResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    def __init__(self,
        ) -> None: ...
global___CleanupGraphResponse = CleanupGraphResponse

class RecvTensorRequest(google.protobuf.message.Message):
    """//////////////////////////////////////////////////////////////////////////////

    RecvTensor method request/response messages

    //////////////////////////////////////////////////////////////////////////////

    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    STEP_ID_FIELD_NUMBER: builtins.int
    RENDEZVOUS_KEY_FIELD_NUMBER: builtins.int
    DMA_OK_FIELD_NUMBER: builtins.int
    CLIENT_LOCALITY_FIELD_NUMBER: builtins.int
    SERVER_LOCALITY_FIELD_NUMBER: builtins.int
    TRANSPORT_OPTIONS_FIELD_NUMBER: builtins.int
    REQUEST_ID_FIELD_NUMBER: builtins.int
    step_id: builtins.int
    """The step in which the tensor will be produced.

    REQUIRED: This must eventually correspond to the `step_id` passed
    into a RunGraph call on the same WorkerService.
    """

    rendezvous_key: typing.Text
    """A key identifying the channel to receive tensors from. A RecvTensor request
    retrieves one tensor from the channel, but multiple tensors can be sent and
    received over the same channel with multiple RecvTensor requests. See
    rendezvous.h for details.
    """

    dma_ok: builtins.bool
    """If true, use an out-of-band DMA mechanism to transfer the
    received tensor.
    """

    @property
    def client_locality(self) -> tensorflow.core.framework.device_attributes_pb2.DeviceLocality:
        """Optional information on client-side device locality."""
        pass
    @property
    def server_locality(self) -> tensorflow.core.framework.device_attributes_pb2.DeviceLocality:
        """Optional information on server-side device locality."""
        pass
    @property
    def transport_options(self) -> google.protobuf.any_pb2.Any:
        """Optional information needed by the RPC subsystem."""
        pass
    request_id: builtins.int
    """Unique identifier for this request. Every RecvTensorRequest must have a
    unique request_id, and retried RecvTensorRequests must have the same
    request_id. If request_id is zero, retry detection and response cache
    are disabled.

    Retried RecvTensorRequests are problematic because a RecvTensor with no
    corresponding sender will wait forever, and the tensor may have been
    delivered to a previous retry. Workers use request_ids to reject retried
    RecvTensor requests instead of waiting forever.
    """

    def __init__(self,
        *,
        step_id: builtins.int = ...,
        rendezvous_key: typing.Text = ...,
        dma_ok: builtins.bool = ...,
        client_locality: typing.Optional[tensorflow.core.framework.device_attributes_pb2.DeviceLocality] = ...,
        server_locality: typing.Optional[tensorflow.core.framework.device_attributes_pb2.DeviceLocality] = ...,
        transport_options: typing.Optional[google.protobuf.any_pb2.Any] = ...,
        request_id: builtins.int = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["client_locality",b"client_locality","server_locality",b"server_locality","transport_options",b"transport_options"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["client_locality",b"client_locality","dma_ok",b"dma_ok","rendezvous_key",b"rendezvous_key","request_id",b"request_id","server_locality",b"server_locality","step_id",b"step_id","transport_options",b"transport_options"]) -> None: ...
global___RecvTensorRequest = RecvTensorRequest

class RecvTensorResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    TENSOR_FIELD_NUMBER: builtins.int
    IS_DEAD_FIELD_NUMBER: builtins.int
    SEND_START_MICROS_FIELD_NUMBER: builtins.int
    TRANSPORT_OPTIONS_FIELD_NUMBER: builtins.int
    REQUIRE_ACK_FIELD_NUMBER: builtins.int
    @property
    def tensor(self) -> tensorflow.core.framework.tensor_pb2.TensorProto:
        """The tensor as a proto."""
        pass
    is_dead: builtins.bool
    """If true, this tensor was the output of a dead node, and the
    content is invalid.
    """

    send_start_micros: builtins.int
    """The time at which tensor was available and started to be returned."""

    @property
    def transport_options(self) -> google.protobuf.any_pb2.Any:
        """Optional additional information about how to receive the tensor,
        e.g. in the event that `RecvTensorRequest.dma_ok` was true.
        """
        pass
    require_ack: builtins.bool
    """Whether the receiver should send a MarkRecvFinishedRequest to the sender
    to ack the message.
    """

    def __init__(self,
        *,
        tensor: typing.Optional[tensorflow.core.framework.tensor_pb2.TensorProto] = ...,
        is_dead: builtins.bool = ...,
        send_start_micros: builtins.int = ...,
        transport_options: typing.Optional[google.protobuf.any_pb2.Any] = ...,
        require_ack: builtins.bool = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["tensor",b"tensor","transport_options",b"transport_options"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["is_dead",b"is_dead","require_ack",b"require_ack","send_start_micros",b"send_start_micros","tensor",b"tensor","transport_options",b"transport_options"]) -> None: ...
global___RecvTensorResponse = RecvTensorResponse

class MarkRecvFinishedRequest(google.protobuf.message.Message):
    """Message for managing the response cache maintained on the sender side.
    Currently only used by the gRPC worker service.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    REQUEST_ID_FIELD_NUMBER: builtins.int
    request_id: builtins.int
    def __init__(self,
        *,
        request_id: builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["request_id",b"request_id"]) -> None: ...
global___MarkRecvFinishedRequest = MarkRecvFinishedRequest

class MarkRecvFinishedResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    def __init__(self,
        ) -> None: ...
global___MarkRecvFinishedResponse = MarkRecvFinishedResponse

class LoggingRequest(google.protobuf.message.Message):
    """//////////////////////////////////////////////////////////////////////////////

    Logging method request/response messages

    NOTE(mrry): This feature is not supported in the open-source
    version, and these messages are expected to change.

    //////////////////////////////////////////////////////////////////////////////

    Out-of-band request to begin or end logging, or
    to retrieve logs for particular steps.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    ENABLE_RPC_LOGGING_FIELD_NUMBER: builtins.int
    DISABLE_RPC_LOGGING_FIELD_NUMBER: builtins.int
    CLEAR_FIELD_NUMBER: builtins.int
    FETCH_STEP_ID_FIELD_NUMBER: builtins.int
    enable_rpc_logging: builtins.bool
    """If true, RPC logging will be enabled."""

    disable_rpc_logging: builtins.bool
    """If true, RPC logging will be disabled."""

    clear: builtins.bool
    """If true, discard any saved logging data (for all steps)."""

    @property
    def fetch_step_id(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """When set, requests all saved log data pertaining to the step.
        Any log data retrieved is eliminated from the store and cannot be
        retrieved again.
        """
        pass
    def __init__(self,
        *,
        enable_rpc_logging: builtins.bool = ...,
        disable_rpc_logging: builtins.bool = ...,
        clear: builtins.bool = ...,
        fetch_step_id: typing.Optional[typing.Iterable[builtins.int]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["clear",b"clear","disable_rpc_logging",b"disable_rpc_logging","enable_rpc_logging",b"enable_rpc_logging","fetch_step_id",b"fetch_step_id"]) -> None: ...
global___LoggingRequest = LoggingRequest

class LabeledStepStats(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    STEP_ID_FIELD_NUMBER: builtins.int
    STEP_STATS_FIELD_NUMBER: builtins.int
    step_id: builtins.int
    @property
    def step_stats(self) -> tensorflow.core.framework.step_stats_pb2.StepStats: ...
    def __init__(self,
        *,
        step_id: builtins.int = ...,
        step_stats: typing.Optional[tensorflow.core.framework.step_stats_pb2.StepStats] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["step_stats",b"step_stats"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["step_id",b"step_id","step_stats",b"step_stats"]) -> None: ...
global___LabeledStepStats = LabeledStepStats

class LoggingResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    STEP_FIELD_NUMBER: builtins.int
    @property
    def step(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___LabeledStepStats]: ...
    def __init__(self,
        *,
        step: typing.Optional[typing.Iterable[global___LabeledStepStats]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["step",b"step"]) -> None: ...
global___LoggingResponse = LoggingResponse

class TraceOpts(google.protobuf.message.Message):
    """//////////////////////////////////////////////////////////////////////////////

    Tracing method request/response messages

    NOTE(mrry): This feature is not supported in the open-source
    version, and these messages are expected to change.

    //////////////////////////////////////////////////////////////////////////////

    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    DURATION_FIELD_NUMBER: builtins.int
    USE_STEP_PROFILER_FIELD_NUMBER: builtins.int
    USE_KERNEL_PROFILER_FIELD_NUMBER: builtins.int
    USE_EXTENDED_PROFILER_FIELD_NUMBER: builtins.int
    USE_GPU_PROFILER_FIELD_NUMBER: builtins.int
    USE_SAMPLE_PROFILER_FIELD_NUMBER: builtins.int
    duration: builtins.float
    """Length of the trace to be taken, in seconds."""

    use_step_profiler: builtins.bool
    """If true, capture step profile locally in each worker. Currently
    unimplemented.
    """

    use_kernel_profiler: builtins.bool
    """If true, capture kernel events from each worker."""

    use_extended_profiler: builtins.bool
    """If true, capture extended profiling events from TensorFlow process."""

    use_gpu_profiler: builtins.bool
    """If true, capture GPU profiling events locally on each
    machine. Currently unimplemented.
    """

    use_sample_profiler: builtins.bool
    """If true, collect sampled profile events. Currently unimplemented."""

    def __init__(self,
        *,
        duration: builtins.float = ...,
        use_step_profiler: builtins.bool = ...,
        use_kernel_profiler: builtins.bool = ...,
        use_extended_profiler: builtins.bool = ...,
        use_gpu_profiler: builtins.bool = ...,
        use_sample_profiler: builtins.bool = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["duration",b"duration","use_extended_profiler",b"use_extended_profiler","use_gpu_profiler",b"use_gpu_profiler","use_kernel_profiler",b"use_kernel_profiler","use_sample_profiler",b"use_sample_profiler","use_step_profiler",b"use_step_profiler"]) -> None: ...
global___TraceOpts = TraceOpts

class TracingRequest(google.protobuf.message.Message):
    """Out-of-band request to configure distributed tracing."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    OPTIONS_FIELD_NUMBER: builtins.int
    @property
    def options(self) -> global___TraceOpts: ...
    def __init__(self,
        *,
        options: typing.Optional[global___TraceOpts] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["options",b"options"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["options",b"options"]) -> None: ...
global___TracingRequest = TracingRequest

class TracingResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    def __init__(self,
        ) -> None: ...
global___TracingResponse = TracingResponse

class RecvBufRequest(google.protobuf.message.Message):
    """//////////////////////////////////////////////////////////////////////////////

    Raw data transfers in support of Collective Ops.
    These methods are experimental and subject to change.

    The intention is to allow collectives to take advantage of the most
    efficient methods available on a platform, e.g. RDMA, and not be
    constrained to use the RPC system in use by other methods.

    //////////////////////////////////////////////////////////////////////////////

    Use of the fields below may vary by implementation.  For example
    the buf_ptr and num_bytes may be set only for local operations and
    not sent on the wire, or only sent on the wire in one direction.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    STEP_ID_FIELD_NUMBER: builtins.int
    BUF_RENDEZVOUS_KEY_FIELD_NUMBER: builtins.int
    NUM_BYTES_FIELD_NUMBER: builtins.int
    BUF_PTR_FIELD_NUMBER: builtins.int
    CLIENT_LOCALITY_FIELD_NUMBER: builtins.int
    SERVER_LOCALITY_FIELD_NUMBER: builtins.int
    TRANSPORT_OPTIONS_FIELD_NUMBER: builtins.int
    SRC_DEVICE_FIELD_NUMBER: builtins.int
    DST_DEVICE_FIELD_NUMBER: builtins.int
    REQUEST_ID_FIELD_NUMBER: builtins.int
    SRC_INCARNATION_FIELD_NUMBER: builtins.int
    step_id: builtins.int
    """Used at server side to find the correct BufRendezvous."""

    buf_rendezvous_key: typing.Text
    """Arbitrary string identifying a BufRendezvous entry."""

    num_bytes: builtins.int
    """Size of value expected, must agree with BufRendezvous entry."""

    buf_ptr: builtins.int
    """When RDMA is in use, address of destination field on client."""

    @property
    def client_locality(self) -> tensorflow.core.framework.device_attributes_pb2.DeviceLocality:
        """Optional information on client-side device locality."""
        pass
    @property
    def server_locality(self) -> tensorflow.core.framework.device_attributes_pb2.DeviceLocality:
        """Optional information on server-side device locality."""
        pass
    @property
    def transport_options(self) -> google.protobuf.any_pb2.Any:
        """Optional, implementation-specific data."""
        pass
    src_device: typing.Text
    """For annotating timeline and device incarnation check."""

    dst_device: typing.Text
    """Optional, for annotating the timeline."""

    request_id: builtins.int
    """Depending on the RPC system in use, it may be necessary to set this
    id to detect resends of RPCs where the server is not aware that
    the prior RPC failed.
    """

    src_incarnation: builtins.int
    """Incarnation number of the source device, used to detect worker failures."""

    def __init__(self,
        *,
        step_id: builtins.int = ...,
        buf_rendezvous_key: typing.Text = ...,
        num_bytes: builtins.int = ...,
        buf_ptr: builtins.int = ...,
        client_locality: typing.Optional[tensorflow.core.framework.device_attributes_pb2.DeviceLocality] = ...,
        server_locality: typing.Optional[tensorflow.core.framework.device_attributes_pb2.DeviceLocality] = ...,
        transport_options: typing.Optional[google.protobuf.any_pb2.Any] = ...,
        src_device: typing.Text = ...,
        dst_device: typing.Text = ...,
        request_id: builtins.int = ...,
        src_incarnation: builtins.int = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["client_locality",b"client_locality","server_locality",b"server_locality","transport_options",b"transport_options"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["buf_ptr",b"buf_ptr","buf_rendezvous_key",b"buf_rendezvous_key","client_locality",b"client_locality","dst_device",b"dst_device","num_bytes",b"num_bytes","request_id",b"request_id","server_locality",b"server_locality","src_device",b"src_device","src_incarnation",b"src_incarnation","step_id",b"step_id","transport_options",b"transport_options"]) -> None: ...
global___RecvBufRequest = RecvBufRequest

class RecvBufResponse(google.protobuf.message.Message):
    """Use of the fields below may vary by implementation.  Comments give
    intended use.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    BUF_PTR_FIELD_NUMBER: builtins.int
    NUM_BYTES_FIELD_NUMBER: builtins.int
    IS_DEAD_FIELD_NUMBER: builtins.int
    TRANSPORT_OPTIONS_FIELD_NUMBER: builtins.int
    SEND_START_MICROS_FIELD_NUMBER: builtins.int
    REQUIRE_ACK_FIELD_NUMBER: builtins.int
    buf_ptr: builtins.int
    """Address of source field on server."""

    num_bytes: builtins.int
    """Byte length of buf_ptr field, if set."""

    is_dead: builtins.bool
    """True if value is 'dead' like a tensor."""

    @property
    def transport_options(self) -> google.protobuf.any_pb2.Any:
        """Optional, implementation-specific data."""
        pass
    send_start_micros: builtins.int
    """Optional, for timeline."""

    require_ack: builtins.bool
    """Whether the receiver should send a MarkRecvFinishedRequest to the sender
    to ack the message.
    """

    def __init__(self,
        *,
        buf_ptr: builtins.int = ...,
        num_bytes: builtins.int = ...,
        is_dead: builtins.bool = ...,
        transport_options: typing.Optional[google.protobuf.any_pb2.Any] = ...,
        send_start_micros: builtins.int = ...,
        require_ack: builtins.bool = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["transport_options",b"transport_options"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["buf_ptr",b"buf_ptr","is_dead",b"is_dead","num_bytes",b"num_bytes","require_ack",b"require_ack","send_start_micros",b"send_start_micros","transport_options",b"transport_options"]) -> None: ...
global___RecvBufResponse = RecvBufResponse

class CompleteGroupRequest(google.protobuf.message.Message):
    """//////////////////////////////////////////////////////////////////////////////

    Collective Op dynamic group resolution messages.

    //////////////////////////////////////////////////////////////////////////////

    Supplies one or more device names as members of the group identified by
    group_key.  Service will respond when all group_size devices become known.
    All devices in group must have same type.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    GROUP_KEY_FIELD_NUMBER: builtins.int
    GROUP_SIZE_FIELD_NUMBER: builtins.int
    DEVICE_TYPE_FIELD_NUMBER: builtins.int
    COLLECTIVE_TYPE_FIELD_NUMBER: builtins.int
    DEVICE_ATTRIBUTES_FIELD_NUMBER: builtins.int
    group_key: builtins.int
    group_size: builtins.int
    device_type: typing.Text
    collective_type: builtins.int
    @property
    def device_attributes(self) -> tensorflow.core.framework.device_attributes_pb2.DeviceAttributes: ...
    def __init__(self,
        *,
        group_key: builtins.int = ...,
        group_size: builtins.int = ...,
        device_type: typing.Text = ...,
        collective_type: builtins.int = ...,
        device_attributes: typing.Optional[tensorflow.core.framework.device_attributes_pb2.DeviceAttributes] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["device_attributes",b"device_attributes"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["collective_type",b"collective_type","device_attributes",b"device_attributes","device_type",b"device_type","group_key",b"group_key","group_size",b"group_size"]) -> None: ...
global___CompleteGroupRequest = CompleteGroupRequest

class CompleteGroupResponse(google.protobuf.message.Message):
    """Gives the complete membership of the group identified by group_key."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    GROUP_KEY_FIELD_NUMBER: builtins.int
    GROUP_SIZE_FIELD_NUMBER: builtins.int
    DEVICE_TYPE_FIELD_NUMBER: builtins.int
    NUM_TASKS_FIELD_NUMBER: builtins.int
    COMMUNICATOR_KEY_FIELD_NUMBER: builtins.int
    DEVICE_ATTRIBUTES_FIELD_NUMBER: builtins.int
    group_key: builtins.int
    group_size: builtins.int
    device_type: typing.Text
    num_tasks: builtins.int
    """number of distinct tasks hosting the devices"""

    communicator_key: builtins.bytes
    @property
    def device_attributes(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[tensorflow.core.framework.device_attributes_pb2.DeviceAttributes]: ...
    def __init__(self,
        *,
        group_key: builtins.int = ...,
        group_size: builtins.int = ...,
        device_type: typing.Text = ...,
        num_tasks: builtins.int = ...,
        communicator_key: builtins.bytes = ...,
        device_attributes: typing.Optional[typing.Iterable[tensorflow.core.framework.device_attributes_pb2.DeviceAttributes]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["communicator_key",b"communicator_key","device_attributes",b"device_attributes","device_type",b"device_type","group_key",b"group_key","group_size",b"group_size","num_tasks",b"num_tasks"]) -> None: ...
global___CompleteGroupResponse = CompleteGroupResponse

class CompleteInstanceRequest(google.protobuf.message.Message):
    """Supplies data about one collective op belonging to the instance identified
    by instance_key.  Service will respond when all group_size ops have
    become known.  Most of the data being sent is for correctness checking,
    to ensure that all ops in the instance share common attributes.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    NAME_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    DATA_TYPE_FIELD_NUMBER: builtins.int
    SHAPE_FIELD_NUMBER: builtins.int
    GROUP_KEY_FIELD_NUMBER: builtins.int
    GROUP_SIZE_FIELD_NUMBER: builtins.int
    INSTANCE_KEY_FIELD_NUMBER: builtins.int
    DEVICE_TYPE_FIELD_NUMBER: builtins.int
    SUBDIV_OFFSET_FIELD_NUMBER: builtins.int
    DEVICE_FIELD_NUMBER: builtins.int
    IS_SOURCE_FIELD_NUMBER: builtins.int
    name: typing.Text
    type: builtins.int
    data_type: tensorflow.core.framework.types_pb2.DataType.ValueType
    @property
    def shape(self) -> tensorflow.core.framework.tensor_shape_pb2.TensorShapeProto: ...
    group_key: builtins.int
    group_size: builtins.int
    instance_key: builtins.int
    device_type: typing.Text
    @property
    def subdiv_offset(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]: ...
    device: typing.Text
    is_source: builtins.bool
    def __init__(self,
        *,
        name: typing.Text = ...,
        type: builtins.int = ...,
        data_type: tensorflow.core.framework.types_pb2.DataType.ValueType = ...,
        shape: typing.Optional[tensorflow.core.framework.tensor_shape_pb2.TensorShapeProto] = ...,
        group_key: builtins.int = ...,
        group_size: builtins.int = ...,
        instance_key: builtins.int = ...,
        device_type: typing.Text = ...,
        subdiv_offset: typing.Optional[typing.Iterable[builtins.int]] = ...,
        device: typing.Text = ...,
        is_source: builtins.bool = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["shape",b"shape"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["data_type",b"data_type","device",b"device","device_type",b"device_type","group_key",b"group_key","group_size",b"group_size","instance_key",b"instance_key","is_source",b"is_source","name",b"name","shape",b"shape","subdiv_offset",b"subdiv_offset","type",b"type"]) -> None: ...
global___CompleteInstanceRequest = CompleteInstanceRequest

class CompleteInstanceResponse(google.protobuf.message.Message):
    """Confirms that every op in the instance has consistently declared itself.
    Also gives the source_rank in case of broadcast.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    INSTANCE_KEY_FIELD_NUMBER: builtins.int
    SOURCE_RANK_FIELD_NUMBER: builtins.int
    instance_key: builtins.int
    source_rank: builtins.int
    def __init__(self,
        *,
        instance_key: builtins.int = ...,
        source_rank: builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["instance_key",b"instance_key","source_rank",b"source_rank"]) -> None: ...
global___CompleteInstanceResponse = CompleteInstanceResponse

class GetStepSequenceRequest(google.protobuf.message.Message):
    """Request for next agreed-upon step_id for the specified graph_keys.
    This is used to enable multiple graphs containing nodes from
    a common collective instance to coordinate using the same step_ids.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    GRAPH_KEY_FIELD_NUMBER: builtins.int
    @property
    def graph_key(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]: ...
    def __init__(self,
        *,
        graph_key: typing.Optional[typing.Iterable[builtins.int]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["graph_key",b"graph_key"]) -> None: ...
global___GetStepSequenceRequest = GetStepSequenceRequest

class StepSequence(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    GRAPH_KEY_FIELD_NUMBER: builtins.int
    NEXT_STEP_ID_FIELD_NUMBER: builtins.int
    graph_key: builtins.int
    next_step_id: builtins.int
    def __init__(self,
        *,
        graph_key: builtins.int = ...,
        next_step_id: builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["graph_key",b"graph_key","next_step_id",b"next_step_id"]) -> None: ...
global___StepSequence = StepSequence

class GetStepSequenceResponse(google.protobuf.message.Message):
    """Next valid step_ids for one or more graph_keys."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    STEP_SEQUENCE_FIELD_NUMBER: builtins.int
    @property
    def step_sequence(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___StepSequence]: ...
    def __init__(self,
        *,
        step_sequence: typing.Optional[typing.Iterable[global___StepSequence]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["step_sequence",b"step_sequence"]) -> None: ...
global___GetStepSequenceResponse = GetStepSequenceResponse
