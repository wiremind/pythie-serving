"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import tensorflow.core.framework.tensor_shape_pb2
import tensorflow.core.framework.types_pb2
import tensorflow.core.framework.variable_pb2
import tensorflow.core.framework.versions_pb2
import tensorflow.core.protobuf.struct_pb2
import tensorflow.core.protobuf.trackable_object_graph_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class SavedObjectGraph(google.protobuf.message.Message):
    """A SavedObjectGraph is part of object-based SavedModels in TF 2.0. It
    describes the directed graph of Python objects (or equivalent in other
    languages) that make up a model, with nodes[0] at the root.

    SavedObjectGraph shares some structure with TrackableObjectGraph, but
    SavedObjectGraph belongs to the MetaGraph and contains pointers to functions
    and type information, while TrackableObjectGraph lives in the checkpoint
    and contains pointers only to variable values.

    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class ConcreteFunctionsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text
        @property
        def value(self) -> global___SavedConcreteFunction: ...
        def __init__(self,
            *,
            key: typing.Text = ...,
            value: typing.Optional[global___SavedConcreteFunction] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["value",b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    NODES_FIELD_NUMBER: builtins.int
    CONCRETE_FUNCTIONS_FIELD_NUMBER: builtins.int
    @property
    def nodes(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SavedObject]:
        """Flattened list of objects in the object graph.

        The position of the object in this list indicates its id.
        Nodes[0] is considered the root node.
        """
        pass
    @property
    def concrete_functions(self) -> google.protobuf.internal.containers.MessageMap[typing.Text, global___SavedConcreteFunction]:
        """Information about captures and output structures in concrete functions.
        Referenced from SavedBareConcreteFunction and SavedFunction.
        """
        pass
    def __init__(self,
        *,
        nodes: typing.Optional[typing.Iterable[global___SavedObject]] = ...,
        concrete_functions: typing.Optional[typing.Mapping[typing.Text, global___SavedConcreteFunction]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["concrete_functions",b"concrete_functions","nodes",b"nodes"]) -> None: ...
global___SavedObjectGraph = SavedObjectGraph

class SavedObject(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class SaveableObjectsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text
        @property
        def value(self) -> global___SaveableObject: ...
        def __init__(self,
            *,
            key: typing.Text = ...,
            value: typing.Optional[global___SaveableObject] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["value",b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    CHILDREN_FIELD_NUMBER: builtins.int
    SLOT_VARIABLES_FIELD_NUMBER: builtins.int
    USER_OBJECT_FIELD_NUMBER: builtins.int
    ASSET_FIELD_NUMBER: builtins.int
    FUNCTION_FIELD_NUMBER: builtins.int
    VARIABLE_FIELD_NUMBER: builtins.int
    BARE_CONCRETE_FUNCTION_FIELD_NUMBER: builtins.int
    CONSTANT_FIELD_NUMBER: builtins.int
    RESOURCE_FIELD_NUMBER: builtins.int
    CAPTURED_TENSOR_FIELD_NUMBER: builtins.int
    SAVEABLE_OBJECTS_FIELD_NUMBER: builtins.int
    @property
    def children(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[tensorflow.core.protobuf.trackable_object_graph_pb2.TrackableObjectGraph.TrackableObject.ObjectReference]:
        """Objects which this object depends on: named edges in the dependency
        graph.

        Note: currently only valid if kind == "user_object" or "resource".
        """
        pass
    @property
    def slot_variables(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[tensorflow.core.protobuf.trackable_object_graph_pb2.TrackableObjectGraph.TrackableObject.SlotVariableReference]:
        """Slot variables owned by this object. This describes the three-way
        (optimizer, variable, slot variable) relationship; none of the three
        depend on the others directly.

        Note: currently only valid if kind == "user_object".
        """
        pass
    @property
    def user_object(self) -> global___SavedUserObject: ...
    @property
    def asset(self) -> global___SavedAsset: ...
    @property
    def function(self) -> global___SavedFunction: ...
    @property
    def variable(self) -> global___SavedVariable: ...
    @property
    def bare_concrete_function(self) -> global___SavedBareConcreteFunction: ...
    @property
    def constant(self) -> global___SavedConstant: ...
    @property
    def resource(self) -> global___SavedResource: ...
    @property
    def captured_tensor(self) -> global___CapturedTensor: ...
    @property
    def saveable_objects(self) -> google.protobuf.internal.containers.MessageMap[typing.Text, global___SaveableObject]: ...
    def __init__(self,
        *,
        children: typing.Optional[typing.Iterable[tensorflow.core.protobuf.trackable_object_graph_pb2.TrackableObjectGraph.TrackableObject.ObjectReference]] = ...,
        slot_variables: typing.Optional[typing.Iterable[tensorflow.core.protobuf.trackable_object_graph_pb2.TrackableObjectGraph.TrackableObject.SlotVariableReference]] = ...,
        user_object: typing.Optional[global___SavedUserObject] = ...,
        asset: typing.Optional[global___SavedAsset] = ...,
        function: typing.Optional[global___SavedFunction] = ...,
        variable: typing.Optional[global___SavedVariable] = ...,
        bare_concrete_function: typing.Optional[global___SavedBareConcreteFunction] = ...,
        constant: typing.Optional[global___SavedConstant] = ...,
        resource: typing.Optional[global___SavedResource] = ...,
        captured_tensor: typing.Optional[global___CapturedTensor] = ...,
        saveable_objects: typing.Optional[typing.Mapping[typing.Text, global___SaveableObject]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["asset",b"asset","bare_concrete_function",b"bare_concrete_function","captured_tensor",b"captured_tensor","constant",b"constant","function",b"function","kind",b"kind","resource",b"resource","user_object",b"user_object","variable",b"variable"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["asset",b"asset","bare_concrete_function",b"bare_concrete_function","captured_tensor",b"captured_tensor","children",b"children","constant",b"constant","function",b"function","kind",b"kind","resource",b"resource","saveable_objects",b"saveable_objects","slot_variables",b"slot_variables","user_object",b"user_object","variable",b"variable"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["kind",b"kind"]) -> typing.Optional[typing_extensions.Literal["user_object","asset","function","variable","bare_concrete_function","constant","resource","captured_tensor"]]: ...
global___SavedObject = SavedObject

class SavedUserObject(google.protobuf.message.Message):
    """A SavedUserObject is an object (in the object-oriented language of the
    TensorFlow program) of some user- or framework-defined class other than
    those handled specifically by the other kinds of SavedObjects.

    This object cannot be evaluated as a tensor, and therefore cannot be bound
    to an input of a function.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    IDENTIFIER_FIELD_NUMBER: builtins.int
    VERSION_FIELD_NUMBER: builtins.int
    METADATA_FIELD_NUMBER: builtins.int
    identifier: typing.Text
    """Corresponds to a registration of the type to use in the loading program."""

    @property
    def version(self) -> tensorflow.core.framework.versions_pb2.VersionDef:
        """Version information from the producer of this SavedUserObject."""
        pass
    metadata: typing.Text
    """Metadata for deserializing this object.

    Deprecated! At the time of deprecation, Keras was the only user of this
    field, and its saving and loading code will be updated shortly.
    Please save your application-specific metadata to a separate file.
    """

    def __init__(self,
        *,
        identifier: typing.Text = ...,
        version: typing.Optional[tensorflow.core.framework.versions_pb2.VersionDef] = ...,
        metadata: typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["version",b"version"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["identifier",b"identifier","metadata",b"metadata","version",b"version"]) -> None: ...
global___SavedUserObject = SavedUserObject

class SavedAsset(google.protobuf.message.Message):
    """A SavedAsset points to an asset in the MetaGraph.

    When bound to a function this object evaluates to a tensor with the absolute
    filename. Users should not depend on a particular part of the filename to
    remain stable (e.g. basename could be changed).
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    ASSET_FILE_DEF_INDEX_FIELD_NUMBER: builtins.int
    asset_file_def_index: builtins.int
    """Index into `MetaGraphDef.asset_file_def[]` that describes the Asset.

    Only the field `AssetFileDef.filename` is used. Other fields, such as
    `AssetFileDef.tensor_info`, MUST be ignored.
    """

    def __init__(self,
        *,
        asset_file_def_index: builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["asset_file_def_index",b"asset_file_def_index"]) -> None: ...
global___SavedAsset = SavedAsset

class SavedFunction(google.protobuf.message.Message):
    """A function with multiple signatures, possibly with non-Tensor arguments."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    CONCRETE_FUNCTIONS_FIELD_NUMBER: builtins.int
    FUNCTION_SPEC_FIELD_NUMBER: builtins.int
    @property
    def concrete_functions(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]: ...
    @property
    def function_spec(self) -> global___FunctionSpec: ...
    def __init__(self,
        *,
        concrete_functions: typing.Optional[typing.Iterable[typing.Text]] = ...,
        function_spec: typing.Optional[global___FunctionSpec] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["function_spec",b"function_spec"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["concrete_functions",b"concrete_functions","function_spec",b"function_spec"]) -> None: ...
global___SavedFunction = SavedFunction

class CapturedTensor(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    NAME_FIELD_NUMBER: builtins.int
    CONCRETE_FUNCTION_FIELD_NUMBER: builtins.int
    name: typing.Text
    """Name of captured tensor"""

    concrete_function: typing.Text
    """Name of concrete function which contains the computed graph tensor."""

    def __init__(self,
        *,
        name: typing.Text = ...,
        concrete_function: typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["concrete_function",b"concrete_function","name",b"name"]) -> None: ...
global___CapturedTensor = CapturedTensor

class SavedConcreteFunction(google.protobuf.message.Message):
    """Stores low-level information about a concrete function. Referenced in either
    a SavedFunction or a SavedBareConcreteFunction.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    BOUND_INPUTS_FIELD_NUMBER: builtins.int
    CANONICALIZED_INPUT_SIGNATURE_FIELD_NUMBER: builtins.int
    OUTPUT_SIGNATURE_FIELD_NUMBER: builtins.int
    @property
    def bound_inputs(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]: ...
    @property
    def canonicalized_input_signature(self) -> tensorflow.core.protobuf.struct_pb2.StructuredValue:
        """Input in canonicalized form that was received to create this concrete
        function.
        """
        pass
    @property
    def output_signature(self) -> tensorflow.core.protobuf.struct_pb2.StructuredValue:
        """Output that was the return value of this function after replacing all
        Tensors with TensorSpecs. This can be an arbitrary nested function and will
        be used to reconstruct the full structure from pure tensors.
        """
        pass
    def __init__(self,
        *,
        bound_inputs: typing.Optional[typing.Iterable[builtins.int]] = ...,
        canonicalized_input_signature: typing.Optional[tensorflow.core.protobuf.struct_pb2.StructuredValue] = ...,
        output_signature: typing.Optional[tensorflow.core.protobuf.struct_pb2.StructuredValue] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["canonicalized_input_signature",b"canonicalized_input_signature","output_signature",b"output_signature"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["bound_inputs",b"bound_inputs","canonicalized_input_signature",b"canonicalized_input_signature","output_signature",b"output_signature"]) -> None: ...
global___SavedConcreteFunction = SavedConcreteFunction

class SavedBareConcreteFunction(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    CONCRETE_FUNCTION_NAME_FIELD_NUMBER: builtins.int
    ARGUMENT_KEYWORDS_FIELD_NUMBER: builtins.int
    ALLOWED_POSITIONAL_ARGUMENTS_FIELD_NUMBER: builtins.int
    FUNCTION_SPEC_FIELD_NUMBER: builtins.int
    concrete_function_name: typing.Text
    """Identifies a SavedConcreteFunction."""

    @property
    def argument_keywords(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """A sequence of unique strings, one per Tensor argument."""
        pass
    allowed_positional_arguments: builtins.int
    """The prefix of `argument_keywords` which may be identified by position."""

    @property
    def function_spec(self) -> global___FunctionSpec:
        """The spec of the function that this ConcreteFunction is traced from. This
        allows the ConcreteFunction to be called with nest structure inputs. This
        field may not be populated. If this field is absent, the concrete function
        can only be called with flat inputs.
        TODO(b/169361281): support calling saved ConcreteFunction with structured
        inputs in C++ SavedModel API.
        """
        pass
    def __init__(self,
        *,
        concrete_function_name: typing.Text = ...,
        argument_keywords: typing.Optional[typing.Iterable[typing.Text]] = ...,
        allowed_positional_arguments: builtins.int = ...,
        function_spec: typing.Optional[global___FunctionSpec] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["function_spec",b"function_spec"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["allowed_positional_arguments",b"allowed_positional_arguments","argument_keywords",b"argument_keywords","concrete_function_name",b"concrete_function_name","function_spec",b"function_spec"]) -> None: ...
global___SavedBareConcreteFunction = SavedBareConcreteFunction

class SavedConstant(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    OPERATION_FIELD_NUMBER: builtins.int
    operation: typing.Text
    """An Operation name for a ConstantOp in this SavedObjectGraph's MetaGraph."""

    def __init__(self,
        *,
        operation: typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["operation",b"operation"]) -> None: ...
global___SavedConstant = SavedConstant

class SavedVariable(google.protobuf.message.Message):
    """Represents a Variable that is initialized by loading the contents from the
    checkpoint.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    DTYPE_FIELD_NUMBER: builtins.int
    SHAPE_FIELD_NUMBER: builtins.int
    TRAINABLE_FIELD_NUMBER: builtins.int
    SYNCHRONIZATION_FIELD_NUMBER: builtins.int
    AGGREGATION_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    DEVICE_FIELD_NUMBER: builtins.int
    EXPERIMENTAL_DISTRIBUTED_VARIABLE_COMPONENTS_FIELD_NUMBER: builtins.int
    dtype: tensorflow.core.framework.types_pb2.DataType.ValueType
    @property
    def shape(self) -> tensorflow.core.framework.tensor_shape_pb2.TensorShapeProto: ...
    trainable: builtins.bool
    synchronization: tensorflow.core.framework.variable_pb2.VariableSynchronization.ValueType
    aggregation: tensorflow.core.framework.variable_pb2.VariableAggregation.ValueType
    name: typing.Text
    device: typing.Text
    @property
    def experimental_distributed_variable_components(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SavedVariable]:
        """List of component variables for a distributed variable.

        When this field is non-empty, the SavedVariable will be assumed
        to be a distributed variable defined by the components listed here.

        This is only supported by experimental loaders at the moment.
        """
        pass
    def __init__(self,
        *,
        dtype: tensorflow.core.framework.types_pb2.DataType.ValueType = ...,
        shape: typing.Optional[tensorflow.core.framework.tensor_shape_pb2.TensorShapeProto] = ...,
        trainable: builtins.bool = ...,
        synchronization: tensorflow.core.framework.variable_pb2.VariableSynchronization.ValueType = ...,
        aggregation: tensorflow.core.framework.variable_pb2.VariableAggregation.ValueType = ...,
        name: typing.Text = ...,
        device: typing.Text = ...,
        experimental_distributed_variable_components: typing.Optional[typing.Iterable[global___SavedVariable]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["shape",b"shape"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["aggregation",b"aggregation","device",b"device","dtype",b"dtype","experimental_distributed_variable_components",b"experimental_distributed_variable_components","name",b"name","shape",b"shape","synchronization",b"synchronization","trainable",b"trainable"]) -> None: ...
global___SavedVariable = SavedVariable

class FunctionSpec(google.protobuf.message.Message):
    """Represents `FunctionSpec` used in `Function`. This represents a
    function that has been wrapped as a TensorFlow `Function`.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _JitCompile:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _JitCompileEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[FunctionSpec._JitCompile.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        DEFAULT: FunctionSpec._JitCompile.ValueType  # 0
        ON: FunctionSpec._JitCompile.ValueType  # 1
        OFF: FunctionSpec._JitCompile.ValueType  # 2
    class JitCompile(_JitCompile, metaclass=_JitCompileEnumTypeWrapper):
        """Whether the function should be compiled by XLA.

        The public interface to `tf.function` uses an optional boolean to
        represent three distinct states for this field.  Unfortunately, proto3
        removes the ability to explicitly check for the presence or absence of a
        field, so we instead map to an enum.

        See `tf.function` for details.
        """
        pass

    DEFAULT: FunctionSpec.JitCompile.ValueType  # 0
    ON: FunctionSpec.JitCompile.ValueType  # 1
    OFF: FunctionSpec.JitCompile.ValueType  # 2

    FULLARGSPEC_FIELD_NUMBER: builtins.int
    IS_METHOD_FIELD_NUMBER: builtins.int
    INPUT_SIGNATURE_FIELD_NUMBER: builtins.int
    JIT_COMPILE_FIELD_NUMBER: builtins.int
    @property
    def fullargspec(self) -> tensorflow.core.protobuf.struct_pb2.StructuredValue:
        """Full arg spec from inspect.getfullargspec()."""
        pass
    is_method: builtins.bool
    """Whether this represents a class method."""

    @property
    def input_signature(self) -> tensorflow.core.protobuf.struct_pb2.StructuredValue:
        """The input signature, if specified."""
        pass
    jit_compile: global___FunctionSpec.JitCompile.ValueType
    def __init__(self,
        *,
        fullargspec: typing.Optional[tensorflow.core.protobuf.struct_pb2.StructuredValue] = ...,
        is_method: builtins.bool = ...,
        input_signature: typing.Optional[tensorflow.core.protobuf.struct_pb2.StructuredValue] = ...,
        jit_compile: global___FunctionSpec.JitCompile.ValueType = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["fullargspec",b"fullargspec","input_signature",b"input_signature"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["fullargspec",b"fullargspec","input_signature",b"input_signature","is_method",b"is_method","jit_compile",b"jit_compile"]) -> None: ...
global___FunctionSpec = FunctionSpec

class SavedResource(google.protobuf.message.Message):
    """A SavedResource represents a TF object that holds state during its lifetime.
    An object of this type can have a reference to a:
    create_resource() and an initialize() function.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    DEVICE_FIELD_NUMBER: builtins.int
    device: typing.Text
    """A device specification indicating a required placement for the resource
    creation function, e.g. "CPU". An empty string allows the user to select a
    device.
    """

    def __init__(self,
        *,
        device: typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["device",b"device"]) -> None: ...
global___SavedResource = SavedResource

class SaveableObject(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    SAVE_FUNCTION_FIELD_NUMBER: builtins.int
    RESTORE_FUNCTION_FIELD_NUMBER: builtins.int
    save_function: builtins.int
    """Node ids of concrete functions for saving and loading from a checkpoint."""

    restore_function: builtins.int
    def __init__(self,
        *,
        save_function: builtins.int = ...,
        restore_function: builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["restore_function",b"restore_function","save_function",b"save_function"]) -> None: ...
global___SaveableObject = SaveableObject
