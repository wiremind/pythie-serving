"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
Copyright 2017 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""
import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import sys
import tensorflow.lite.toco.types_pb2
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing_extensions.final
class InputArrayShape(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DIMS_FIELD_NUMBER: builtins.int
    UNKNOWN_RANK_FIELD_NUMBER: builtins.int
    @property
    def dims(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """Dimensions of the tensor."""
    unknown_rank: builtins.bool
    """If true, the number of dimensions in the shape is unknown.

    If true, "dims.size()" must be 0.
    """
    def __init__(
        self,
        *,
        dims: collections.abc.Iterable[builtins.int] | None = ...,
        unknown_rank: builtins.bool | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["unknown_rank", b"unknown_rank"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["dims", b"dims", "unknown_rank", b"unknown_rank"]) -> None: ...

global___InputArrayShape = InputArrayShape

@typing_extensions.final
class InputArray(google.protobuf.message.Message):
    """Next ID to USE: 7."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAME_FIELD_NUMBER: builtins.int
    SHAPE_FIELD_NUMBER: builtins.int
    MEAN_VALUE_FIELD_NUMBER: builtins.int
    STD_VALUE_FIELD_NUMBER: builtins.int
    DATA_TYPE_FIELD_NUMBER: builtins.int
    name: builtins.str
    """Name of the input arrays, i.e. the arrays from which input activations
    will be read.
    """
    @property
    def shape(self) -> global___InputArrayShape:
        """Shape of the input.  For many applications the dimensions are {batch,
        height, width, depth}.  Often the batch is left "unspecified" by providing
        a value of -1.

        The last dimension is typically called 'depth' or 'channels'. For example,
        for an image model taking RGB images as input, this would have the value 3.
        """
    mean_value: builtins.float
    """mean_value and std_value parameters control the interpretation of raw input
    activation values (elements of the input array) as real numbers. The
    mapping is given by:

       real_value = (raw_input_value - mean_value) / std_value

    In particular, the defaults (mean_value=0, std_value=1) yield
    real_value = raw_input_value. Often, non-default values are used in image
    models. For example, an image model taking uint8 image channel values as
    its raw inputs, in [0, 255] range, may use mean_value=128, std_value=128 to
    map them into the interval [-1, 1).

    Note: this matches exactly the meaning of mean_value and std_value in
    (TensorFlow via LegacyFedInput).
    """
    std_value: builtins.float
    data_type: tensorflow.lite.toco.types_pb2.IODataType.ValueType
    """Data type of the input.

    In many graphs, the input arrays already have defined data types,
    e.g. Placeholder nodes in a TensorFlow GraphDef have a dtype attribute.
    In those cases, it is not needed to specify this data_type flag.
    The purpose of this flag is only to define the data type of input
    arrays whose type isn't defined in the input graph file. For example,
    when specifying an arbitrary (not Placeholder) --input_array into
    a TensorFlow GraphDef.

    When this data_type is quantized (e.g. QUANTIZED_UINT8), the
    corresponding quantization parameters are the mean_value, std_value
    fields.

    It is also important to understand the nuance between this data_type
    flag and the inference_input_type in TocoFlags. The basic difference
    is that this data_type (like all ModelFlags) describes a property
    of the input graph, while inference_input_type (like all TocoFlags)
    describes an aspect of the toco transformation process and thus of
    the output file. The types of input arrays may be different between
    the input and output files if quantization or dequantization occurred.
    Such differences can only occur for real-number data i.e. only
    between FLOAT and quantized types (e.g. QUANTIZED_UINT8).
    """
    def __init__(
        self,
        *,
        name: builtins.str | None = ...,
        shape: global___InputArrayShape | None = ...,
        mean_value: builtins.float | None = ...,
        std_value: builtins.float | None = ...,
        data_type: tensorflow.lite.toco.types_pb2.IODataType.ValueType | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["data_type", b"data_type", "mean_value", b"mean_value", "name", b"name", "shape", b"shape", "std_value", b"std_value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["data_type", b"data_type", "mean_value", b"mean_value", "name", b"name", "shape", b"shape", "std_value", b"std_value"]) -> None: ...

global___InputArray = InputArray

@typing_extensions.final
class RnnState(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    STATE_ARRAY_FIELD_NUMBER: builtins.int
    BACK_EDGE_SOURCE_ARRAY_FIELD_NUMBER: builtins.int
    DISCARDABLE_FIELD_NUMBER: builtins.int
    SIZE_FIELD_NUMBER: builtins.int
    NUM_DIMS_FIELD_NUMBER: builtins.int
    state_array: builtins.str
    back_edge_source_array: builtins.str
    discardable: builtins.bool
    size: builtins.int
    """size allows to specify a 1-D shape for the RNN state array.
    Will be expanded with 1's to fit the model.
    TODO(benoitjacob): should allow a generic, explicit shape.
    """
    num_dims: builtins.int
    def __init__(
        self,
        *,
        state_array: builtins.str | None = ...,
        back_edge_source_array: builtins.str | None = ...,
        discardable: builtins.bool | None = ...,
        size: builtins.int | None = ...,
        num_dims: builtins.int | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["back_edge_source_array", b"back_edge_source_array", "discardable", b"discardable", "num_dims", b"num_dims", "size", b"size", "state_array", b"state_array"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["back_edge_source_array", b"back_edge_source_array", "discardable", b"discardable", "num_dims", b"num_dims", "size", b"size", "state_array", b"state_array"]) -> None: ...

global___RnnState = RnnState

@typing_extensions.final
class ArraysExtraInfo(google.protobuf.message.Message):
    """An ArraysExtraInfo message stores a collection of additional Information
    about arrays in a model, complementing the information in the model itself.
    It is intentionally a separate message so that it may be serialized and
    passed separately from the model. See --arrays_extra_info_file.

    A typical use case is to manually specify MinMax for specific arrays in a
    model that does not already contain such MinMax information.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing_extensions.final
    class Entry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        NAME_FIELD_NUMBER: builtins.int
        NAME_REGEXP_FIELD_NUMBER: builtins.int
        MIN_FIELD_NUMBER: builtins.int
        MAX_FIELD_NUMBER: builtins.int
        DATA_TYPE_FIELD_NUMBER: builtins.int
        SHAPE_FIELD_NUMBER: builtins.int
        CONSTANT_FLOAT_VALUE_FIELD_NUMBER: builtins.int
        name: builtins.str
        """Next ID to use: 8."""
        name_regexp: builtins.str
        min: builtins.float
        max: builtins.float
        data_type: tensorflow.lite.toco.types_pb2.IODataType.ValueType
        @property
        def shape(self) -> global___InputArrayShape: ...
        constant_float_value: builtins.float
        def __init__(
            self,
            *,
            name: builtins.str | None = ...,
            name_regexp: builtins.str | None = ...,
            min: builtins.float | None = ...,
            max: builtins.float | None = ...,
            data_type: tensorflow.lite.toco.types_pb2.IODataType.ValueType | None = ...,
            shape: global___InputArrayShape | None = ...,
            constant_float_value: builtins.float | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["constant_float_value", b"constant_float_value", "data_type", b"data_type", "max", b"max", "min", b"min", "name", b"name", "name_regexp", b"name_regexp", "shape", b"shape"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["constant_float_value", b"constant_float_value", "data_type", b"data_type", "max", b"max", "min", b"min", "name", b"name", "name_regexp", b"name_regexp", "shape", b"shape"]) -> None: ...

    ENTRIES_FIELD_NUMBER: builtins.int
    @property
    def entries(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ArraysExtraInfo.Entry]: ...
    def __init__(
        self,
        *,
        entries: collections.abc.Iterable[global___ArraysExtraInfo.Entry] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["entries", b"entries"]) -> None: ...

global___ArraysExtraInfo = ArraysExtraInfo

@typing_extensions.final
class ModelFlags(google.protobuf.message.Message):
    """ModelFlags encodes properties of a model that, depending on the file
    format, may or may not be recorded in the model file. The purpose of
    representing these properties in ModelFlags is to allow passing them
    separately from the input model file, for instance as command-line
    parameters, so that we can offer a single uniform interface that can
    handle files from different input formats.

    For each of these properties, and each supported file format, we
    detail in comments below whether the property exists in the given file
    format.

    Obsolete flags that have been removed:
      optional int32 input_depth = 3;
      optional int32 input_width = 4;
      optional int32 input_height = 5;
      optional int32 batch = 6 [ default = 1];
      optional float mean_value = 7;
      optional float std_value = 8 [default = 1.];
      optional int32 input_dims = 11 [ default = 4];
      repeated int32 input_shape = 13;

    Next ID to USE: 27.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _HloFileType:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _HloFileTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[ModelFlags._HloFileType.ValueType], builtins.type):  # noqa: F821
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        UNKNOWN: ModelFlags._HloFileType.ValueType  # 0
        HLO_TEXT: ModelFlags._HloFileType.ValueType  # 1
        HLO_PROTO: ModelFlags._HloFileType.ValueType  # 2

    class HloFileType(_HloFileType, metaclass=_HloFileTypeEnumTypeWrapper):
        """The hlo file type enum."""

    UNKNOWN: ModelFlags.HloFileType.ValueType  # 0
    HLO_TEXT: ModelFlags.HloFileType.ValueType  # 1
    HLO_PROTO: ModelFlags.HloFileType.ValueType  # 2

    @typing_extensions.final
    class ModelCheck(google.protobuf.message.Message):
        """Checks applied to the model, typically after toco's comprehensive
        graph transformations.
        Next ID to USE: 4.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        COUNT_TYPE_FIELD_NUMBER: builtins.int
        COUNT_MIN_FIELD_NUMBER: builtins.int
        COUNT_MAX_FIELD_NUMBER: builtins.int
        count_type: builtins.str
        """Use the name of a type of operator to check its counts.
        Use "Total" for overall operator counts.
        Use "Arrays" for overall array counts.
        """
        count_min: builtins.int
        """A count of zero is a meaningful check, so negative used to mean disable."""
        count_max: builtins.int
        """If count_max < count_min, then count_min is only allowed value."""
        def __init__(
            self,
            *,
            count_type: builtins.str | None = ...,
            count_min: builtins.int | None = ...,
            count_max: builtins.int | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["count_max", b"count_max", "count_min", b"count_min", "count_type", b"count_type"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["count_max", b"count_max", "count_min", b"count_min", "count_type", b"count_type"]) -> None: ...

    INPUT_ARRAYS_FIELD_NUMBER: builtins.int
    OUTPUT_ARRAYS_FIELD_NUMBER: builtins.int
    CONTROL_OUTPUT_ARRAYS_FIELD_NUMBER: builtins.int
    VARIABLE_BATCH_FIELD_NUMBER: builtins.int
    RNN_STATES_FIELD_NUMBER: builtins.int
    MODEL_CHECKS_FIELD_NUMBER: builtins.int
    ALLOW_NONEXISTENT_ARRAYS_FIELD_NUMBER: builtins.int
    ALLOW_NONASCII_ARRAYS_FIELD_NUMBER: builtins.int
    ARRAYS_EXTRA_INFO_FIELD_NUMBER: builtins.int
    CHANGE_CONCAT_INPUT_RANGES_FIELD_NUMBER: builtins.int
    SAVED_MODEL_DIR_FIELD_NUMBER: builtins.int
    SAVED_MODEL_VERSION_FIELD_NUMBER: builtins.int
    SAVED_MODEL_TAGS_FIELD_NUMBER: builtins.int
    SAVED_MODEL_EXPORTED_NAMES_FIELD_NUMBER: builtins.int
    USE_HLO_IMPORT_FIELD_NUMBER: builtins.int
    HLO_FILE_TYPE_FIELD_NUMBER: builtins.int
    @property
    def input_arrays(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___InputArray]:
        """Information about the input arrays, i.e. the arrays from which input
        activations will be read.
        """
    @property
    def output_arrays(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """Name of the output arrays, i.e. the arrays into which output activations
        will be written.
        """
    @property
    def control_output_arrays(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """Name of the control outputs."""
    variable_batch: builtins.bool
    """If true, the model accepts an arbitrary batch size. Mutually exclusive with
    the 'batch' field: at most one of these two fields can be set.
    """
    @property
    def rnn_states(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___RnnState]: ...
    @property
    def model_checks(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ModelFlags.ModelCheck]: ...
    allow_nonexistent_arrays: builtins.bool
    """If true, will allow passing inexistent arrays in --input_arrays
    and --output_arrays. This makes little sense, is only useful to
    more easily get graph visualizations.
    """
    allow_nonascii_arrays: builtins.bool
    """If true, will allow passing non-ascii-printable characters in
    --input_arrays and --output_arrays. By default (if false), only
    ascii printable characters are allowed, i.e. character codes
    ranging from 32 to 127. This is disallowed by default so as to
    catch common copy-and-paste issues where invisible unicode
    characters are unwittingly added to these strings.
    """
    @property
    def arrays_extra_info(self) -> global___ArraysExtraInfo:
        """If set, this ArraysExtraInfo allows to pass extra information about arrays
        not specified in the input model file, such as extra MinMax information.
        """
    change_concat_input_ranges: builtins.bool
    """When set to false, toco will not change the input ranges and the output
    ranges of concat operator to the overlap of all input ranges.
    """
    saved_model_dir: builtins.str
    """Filepath of the saved model to be converted. This value will be non-empty
    only when the saved model import path will be used. Otherwise, the graph
    def-based conversion will be processed.
    """
    saved_model_version: builtins.int
    """SavedModel file format version of The saved model file to be converted.
    This value will be set only when the SavedModel import path will be used.
    """
    @property
    def saved_model_tags(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """Set of string saved model tags, formatted in the comma-separated value.
        This value will be set only when the SavedModel import path will be used.
        """
    @property
    def saved_model_exported_names(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """Names to be exported (default: export all) when the saved model import path
        is on. This value will be set only when the SavedModel import path will be
        used.
        """
    use_hlo_import: builtins.bool
    """Whether or not to use hlo import."""
    hlo_file_type: global___ModelFlags.HloFileType.ValueType
    """Hlo file type, this will be used for hlo import."""
    def __init__(
        self,
        *,
        input_arrays: collections.abc.Iterable[global___InputArray] | None = ...,
        output_arrays: collections.abc.Iterable[builtins.str] | None = ...,
        control_output_arrays: collections.abc.Iterable[builtins.str] | None = ...,
        variable_batch: builtins.bool | None = ...,
        rnn_states: collections.abc.Iterable[global___RnnState] | None = ...,
        model_checks: collections.abc.Iterable[global___ModelFlags.ModelCheck] | None = ...,
        allow_nonexistent_arrays: builtins.bool | None = ...,
        allow_nonascii_arrays: builtins.bool | None = ...,
        arrays_extra_info: global___ArraysExtraInfo | None = ...,
        change_concat_input_ranges: builtins.bool | None = ...,
        saved_model_dir: builtins.str | None = ...,
        saved_model_version: builtins.int | None = ...,
        saved_model_tags: collections.abc.Iterable[builtins.str] | None = ...,
        saved_model_exported_names: collections.abc.Iterable[builtins.str] | None = ...,
        use_hlo_import: builtins.bool | None = ...,
        hlo_file_type: global___ModelFlags.HloFileType.ValueType | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["allow_nonascii_arrays", b"allow_nonascii_arrays", "allow_nonexistent_arrays", b"allow_nonexistent_arrays", "arrays_extra_info", b"arrays_extra_info", "change_concat_input_ranges", b"change_concat_input_ranges", "hlo_file_type", b"hlo_file_type", "saved_model_dir", b"saved_model_dir", "saved_model_version", b"saved_model_version", "use_hlo_import", b"use_hlo_import", "variable_batch", b"variable_batch"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["allow_nonascii_arrays", b"allow_nonascii_arrays", "allow_nonexistent_arrays", b"allow_nonexistent_arrays", "arrays_extra_info", b"arrays_extra_info", "change_concat_input_ranges", b"change_concat_input_ranges", "control_output_arrays", b"control_output_arrays", "hlo_file_type", b"hlo_file_type", "input_arrays", b"input_arrays", "model_checks", b"model_checks", "output_arrays", b"output_arrays", "rnn_states", b"rnn_states", "saved_model_dir", b"saved_model_dir", "saved_model_exported_names", b"saved_model_exported_names", "saved_model_tags", b"saved_model_tags", "saved_model_version", b"saved_model_version", "use_hlo_import", b"use_hlo_import", "variable_batch", b"variable_batch"]) -> None: ...

global___ModelFlags = ModelFlags
