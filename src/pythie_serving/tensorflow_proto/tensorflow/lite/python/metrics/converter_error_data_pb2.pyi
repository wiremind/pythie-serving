"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
This schema defines the converter error format to communicate between C++
and python.
"""
import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing_extensions.final
class ConverterErrorData(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _ErrorCode:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _ErrorCodeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[ConverterErrorData._ErrorCode.ValueType], builtins.type):  # noqa: F821
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        UNKNOWN: ConverterErrorData._ErrorCode.ValueType  # 0
        ERROR_NEEDS_FLEX_OPS: ConverterErrorData._ErrorCode.ValueType  # 1
        ERROR_NEEDS_CUSTOM_OPS: ConverterErrorData._ErrorCode.ValueType  # 2
        ERROR_UNSUPPORTED_CONTROL_FLOW_V1: ConverterErrorData._ErrorCode.ValueType  # 3
        ERROR_GPU_NOT_COMPATIBLE: ConverterErrorData._ErrorCode.ValueType  # 200
        """200- 209 error codes are reserved for backend(delegate) compatibility.
        Backend compatibility is checked at MlirToFlatBufferTranslateFunction()
        with the converted flatbuffer model. If some nodes are incompatibile with
        the given backends in TocoFlags.supported_backends, the error will be
        raised.
        """

    class ErrorCode(_ErrorCode, metaclass=_ErrorCodeEnumTypeWrapper):
        """Error code for popular errors."""

    UNKNOWN: ConverterErrorData.ErrorCode.ValueType  # 0
    ERROR_NEEDS_FLEX_OPS: ConverterErrorData.ErrorCode.ValueType  # 1
    ERROR_NEEDS_CUSTOM_OPS: ConverterErrorData.ErrorCode.ValueType  # 2
    ERROR_UNSUPPORTED_CONTROL_FLOW_V1: ConverterErrorData.ErrorCode.ValueType  # 3
    ERROR_GPU_NOT_COMPATIBLE: ConverterErrorData.ErrorCode.ValueType  # 200
    """200- 209 error codes are reserved for backend(delegate) compatibility.
    Backend compatibility is checked at MlirToFlatBufferTranslateFunction()
    with the converted flatbuffer model. If some nodes are incompatibile with
    the given backends in TocoFlags.supported_backends, the error will be
    raised.
    """

    class _LocationType:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _LocationTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[ConverterErrorData._LocationType.ValueType], builtins.type):  # noqa: F821
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        UNKNOWNLOC: ConverterErrorData._LocationType.ValueType  # 0
        """No location information available."""
        NAMELOC: ConverterErrorData._LocationType.ValueType  # 1
        """The location is the nodename;"""
        CALLSITELOC: ConverterErrorData._LocationType.ValueType  # 2
        """The location is a stacktrace."""
        FUSEDLOC: ConverterErrorData._LocationType.ValueType  # 3
        """The location is a fused location, usually represents the list of output
        tensor locations of that node.
        """

    class LocationType(_LocationType, metaclass=_LocationTypeEnumTypeWrapper):
        """Represents the type of location."""

    UNKNOWNLOC: ConverterErrorData.LocationType.ValueType  # 0
    """No location information available."""
    NAMELOC: ConverterErrorData.LocationType.ValueType  # 1
    """The location is the nodename;"""
    CALLSITELOC: ConverterErrorData.LocationType.ValueType  # 2
    """The location is a stacktrace."""
    FUSEDLOC: ConverterErrorData.LocationType.ValueType  # 3
    """The location is a fused location, usually represents the list of output
    tensor locations of that node.
    """

    @typing_extensions.final
    class Operator(google.protobuf.message.Message):
        """Information about the op where the error occurs."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        NAME_FIELD_NUMBER: builtins.int
        name: builtins.str
        """The op name has "<dialect>.<name>" format, Ex: "tf.Abs"."""
        def __init__(
            self,
            *,
            name: builtins.str | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["name", b"name"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["name", b"name"]) -> None: ...

    @typing_extensions.final
    class FileLoc(google.protobuf.message.Message):
        """Represents a source location with file name, line and column number."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        FILENAME_FIELD_NUMBER: builtins.int
        LINE_FIELD_NUMBER: builtins.int
        COLUMN_FIELD_NUMBER: builtins.int
        filename: builtins.str
        line: builtins.int
        column: builtins.int
        def __init__(
            self,
            *,
            filename: builtins.str | None = ...,
            line: builtins.int | None = ...,
            column: builtins.int | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["column", b"column", "filename", b"filename", "line", b"line"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["column", b"column", "filename", b"filename", "line", b"line"]) -> None: ...

    @typing_extensions.final
    class SourceLoc(google.protobuf.message.Message):
        """Represents the node name and its source location."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        NAME_FIELD_NUMBER: builtins.int
        SOURCE_FIELD_NUMBER: builtins.int
        name: builtins.str
        @property
        def source(self) -> global___ConverterErrorData.FileLoc: ...
        def __init__(
            self,
            *,
            name: builtins.str | None = ...,
            source: global___ConverterErrorData.FileLoc | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["name", b"name", "source", b"source"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["name", b"name", "source", b"source"]) -> None: ...

    @typing_extensions.final
    class Location(google.protobuf.message.Message):
        """Represents the location information of current node."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        TYPE_FIELD_NUMBER: builtins.int
        CALL_FIELD_NUMBER: builtins.int
        type: global___ConverterErrorData.LocationType.ValueType
        @property
        def call(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ConverterErrorData.SourceLoc]:
            """For each location type, this field is different. If type is:
            - UNKNOWNLOC: call is empty.
            - NAMELOC: call has a single element representing the current node.
            - CALLSITELOC: call is a chain of source locations representing a
                stacktrace.
            - FUSEDLOC: call is a list, represents the list of output tensor
                locations.
            """
        def __init__(
            self,
            *,
            type: global___ConverterErrorData.LocationType.ValueType | None = ...,
            call: collections.abc.Iterable[global___ConverterErrorData.SourceLoc] | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["type", b"type"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["call", b"call", "type", b"type"]) -> None: ...

    COMPONENT_FIELD_NUMBER: builtins.int
    SUBCOMPONENT_FIELD_NUMBER: builtins.int
    ERROR_CODE_FIELD_NUMBER: builtins.int
    ERROR_MESSAGE_FIELD_NUMBER: builtins.int
    OPERATOR_FIELD_NUMBER: builtins.int
    LOCATION_FIELD_NUMBER: builtins.int
    component: builtins.str
    """The name of the component from which the error was originally thrown."""
    subcomponent: builtins.str
    """The name of the subcomponent from which the error was originally thrown. In
    MLIR, this field contains the pass name.
    """
    error_code: global___ConverterErrorData.ErrorCode.ValueType
    error_message: builtins.str
    @property
    def operator(self) -> global___ConverterErrorData.Operator: ...
    @property
    def location(self) -> global___ConverterErrorData.Location: ...
    def __init__(
        self,
        *,
        component: builtins.str | None = ...,
        subcomponent: builtins.str | None = ...,
        error_code: global___ConverterErrorData.ErrorCode.ValueType | None = ...,
        error_message: builtins.str | None = ...,
        operator: global___ConverterErrorData.Operator | None = ...,
        location: global___ConverterErrorData.Location | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["component", b"component", "error_code", b"error_code", "error_message", b"error_message", "location", b"location", "operator", b"operator", "subcomponent", b"subcomponent"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["component", b"component", "error_code", b"error_code", "error_message", b"error_message", "location", b"location", "operator", b"operator", "subcomponent", b"subcomponent"]) -> None: ...

global___ConverterErrorData = ConverterErrorData
