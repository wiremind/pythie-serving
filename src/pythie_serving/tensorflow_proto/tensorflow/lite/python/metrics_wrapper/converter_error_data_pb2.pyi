"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class ConverterErrorData(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _ErrorCode:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _ErrorCodeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[ConverterErrorData._ErrorCode.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        UNKNOWN: ConverterErrorData._ErrorCode.ValueType  # 0
        ERROR_NEEDS_FLEX_OPS: ConverterErrorData._ErrorCode.ValueType  # 1
        ERROR_NEEDS_CUSTOM_OPS: ConverterErrorData._ErrorCode.ValueType  # 2
        ERROR_UNSUPPORTED_CONTROL_FLOW_V1: ConverterErrorData._ErrorCode.ValueType  # 3
    class ErrorCode(_ErrorCode, metaclass=_ErrorCodeEnumTypeWrapper):
        """Error code for popular errors."""
        pass

    UNKNOWN: ConverterErrorData.ErrorCode.ValueType  # 0
    ERROR_NEEDS_FLEX_OPS: ConverterErrorData.ErrorCode.ValueType  # 1
    ERROR_NEEDS_CUSTOM_OPS: ConverterErrorData.ErrorCode.ValueType  # 2
    ERROR_UNSUPPORTED_CONTROL_FLOW_V1: ConverterErrorData.ErrorCode.ValueType  # 3

    class _LocationType:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _LocationTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[ConverterErrorData._LocationType.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        UNKNOWNLOC: ConverterErrorData._LocationType.ValueType  # 0
        """No location information available."""

        NAMELOC: ConverterErrorData._LocationType.ValueType  # 1
        """The location is the nodename;"""

        CALLSITELOC: ConverterErrorData._LocationType.ValueType  # 2
        """The location is a stacktrace."""

        FUSEDLOC: ConverterErrorData._LocationType.ValueType  # 3
        """The location is a fused location, usually represents the list of output
        tensor locations of that node.
        """

    class LocationType(_LocationType, metaclass=_LocationTypeEnumTypeWrapper):
        """Represents the type of location."""
        pass

    UNKNOWNLOC: ConverterErrorData.LocationType.ValueType  # 0
    """No location information available."""

    NAMELOC: ConverterErrorData.LocationType.ValueType  # 1
    """The location is the nodename;"""

    CALLSITELOC: ConverterErrorData.LocationType.ValueType  # 2
    """The location is a stacktrace."""

    FUSEDLOC: ConverterErrorData.LocationType.ValueType  # 3
    """The location is a fused location, usually represents the list of output
    tensor locations of that node.
    """


    class Operator(google.protobuf.message.Message):
        """Information about the op where the error occurs."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        NAME_FIELD_NUMBER: builtins.int
        name: typing.Text
        """The op name has "<dialect>.<name>" format, Ex: "tf.Abs"."""

        def __init__(self,
            *,
            name: typing.Optional[typing.Text] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["name",b"name"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["name",b"name"]) -> None: ...

    class FileLoc(google.protobuf.message.Message):
        """Represents a source location with file name, line and column number."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        FILENAME_FIELD_NUMBER: builtins.int
        LINE_FIELD_NUMBER: builtins.int
        COLUMN_FIELD_NUMBER: builtins.int
        filename: typing.Text
        line: builtins.int
        column: builtins.int
        def __init__(self,
            *,
            filename: typing.Optional[typing.Text] = ...,
            line: typing.Optional[builtins.int] = ...,
            column: typing.Optional[builtins.int] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["column",b"column","filename",b"filename","line",b"line"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["column",b"column","filename",b"filename","line",b"line"]) -> None: ...

    class SourceLoc(google.protobuf.message.Message):
        """Represents the node name and its source location."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        NAME_FIELD_NUMBER: builtins.int
        SOURCE_FIELD_NUMBER: builtins.int
        name: typing.Text
        @property
        def source(self) -> global___ConverterErrorData.FileLoc: ...
        def __init__(self,
            *,
            name: typing.Optional[typing.Text] = ...,
            source: typing.Optional[global___ConverterErrorData.FileLoc] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["name",b"name","source",b"source"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["name",b"name","source",b"source"]) -> None: ...

    class Location(google.protobuf.message.Message):
        """Represents the location information of current node."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        TYPE_FIELD_NUMBER: builtins.int
        CALL_FIELD_NUMBER: builtins.int
        type: global___ConverterErrorData.LocationType.ValueType
        @property
        def call(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ConverterErrorData.SourceLoc]:
            """For each location type, this field is different. If type is:
            - UNKNOWNLOC: call is empty.
            - NAMELOC: call has a single element representing the current node.
            - CALLSITELOC: call is a chain of source locations representing a
                stacktrace.
            - FUSEDLOC: call is a list, represents the list of output tensor
                locations.
            """
            pass
        def __init__(self,
            *,
            type: typing.Optional[global___ConverterErrorData.LocationType.ValueType] = ...,
            call: typing.Optional[typing.Iterable[global___ConverterErrorData.SourceLoc]] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["type",b"type"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["call",b"call","type",b"type"]) -> None: ...

    COMPONENT_FIELD_NUMBER: builtins.int
    SUBCOMPONENT_FIELD_NUMBER: builtins.int
    ERROR_CODE_FIELD_NUMBER: builtins.int
    ERROR_MESSAGE_FIELD_NUMBER: builtins.int
    OPERATOR_FIELD_NUMBER: builtins.int
    LOCATION_FIELD_NUMBER: builtins.int
    component: typing.Text
    """The name of the component from which the error was originally thrown."""

    subcomponent: typing.Text
    """The name of the subcomponent from which the error was originally thrown. In
    MLIR, this field contains the pass name.
    """

    error_code: global___ConverterErrorData.ErrorCode.ValueType
    error_message: typing.Text
    @property
    def operator(self) -> global___ConverterErrorData.Operator: ...
    @property
    def location(self) -> global___ConverterErrorData.Location: ...
    def __init__(self,
        *,
        component: typing.Optional[typing.Text] = ...,
        subcomponent: typing.Optional[typing.Text] = ...,
        error_code: typing.Optional[global___ConverterErrorData.ErrorCode.ValueType] = ...,
        error_message: typing.Optional[typing.Text] = ...,
        operator: typing.Optional[global___ConverterErrorData.Operator] = ...,
        location: typing.Optional[global___ConverterErrorData.Location] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["component",b"component","error_code",b"error_code","error_message",b"error_message","location",b"location","operator",b"operator","subcomponent",b"subcomponent"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["component",b"component","error_code",b"error_code","error_message",b"error_message","location",b"location","operator",b"operator","subcomponent",b"subcomponent"]) -> None: ...
global___ConverterErrorData = ConverterErrorData
