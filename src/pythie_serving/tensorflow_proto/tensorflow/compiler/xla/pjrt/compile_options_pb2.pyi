"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import sys
import tensorflow.compiler.xla.xla_data_pb2
import tensorflow.compiler.xla.xla_pb2

if sys.version_info >= (3, 8):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing_extensions.final
class ExecutableBuildOptionsProto(google.protobuf.message.Message):
    """A serialization of xla::ExecutableBuildOptions.
    Next id: 13.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DEVICE_ORDINAL_FIELD_NUMBER: builtins.int
    RESULT_LAYOUT_FIELD_NUMBER: builtins.int
    DEBUG_OPTIONS_FIELD_NUMBER: builtins.int
    NUM_REPLICAS_FIELD_NUMBER: builtins.int
    NUM_PARTITIONS_FIELD_NUMBER: builtins.int
    USE_SPMD_PARTITIONING_FIELD_NUMBER: builtins.int
    USE_AUTO_SPMD_PARTITIONING_FIELD_NUMBER: builtins.int
    DEDUPLICATE_HLO_FIELD_NUMBER: builtins.int
    DEVICE_ASSIGNMENT_FIELD_NUMBER: builtins.int
    ALIAS_PASSTHROUGH_PARAMS_FIELD_NUMBER: builtins.int
    RUN_BACKEND_ONLY_FIELD_NUMBER: builtins.int
    ALLOW_SPMD_SHARDING_PROPAGATION_TO_OUTPUT_FIELD_NUMBER: builtins.int
    device_ordinal: builtins.int
    """If set, this is the device to build the computation for. Valid
    device_ordinal values are: 0 to # of devices - 1. These values are
    identical to the device ordinal values used by StreamExecutor. The built
    executable will be executable on any device equivalent to the specified
    device as determined by Backend::devices_equivalent(). A value of -1
    indicates this option has not been set.
    """
    @property
    def result_layout(self) -> tensorflow.compiler.xla.xla_data_pb2.ShapeProto:
        """If set, this specifies the layout of the result of the computation. If not
        set, the service will chose the layout of the result. A Shape is used to
        store the layout to accommodate tuple result shapes. A value of nullptr
        indicates the option has not been set.
        """
    @property
    def debug_options(self) -> tensorflow.compiler.xla.xla_pb2.DebugOptions:
        """Expose access to the XLA debug options which will be passed to the
        compilation process.
        """
    num_replicas: builtins.int
    """The number of replicas of this computation that are to be executed.
    Defaults to 1.
    """
    num_partitions: builtins.int
    """The number of partitions in this computation. Defaults to 1."""
    use_spmd_partitioning: builtins.bool
    """Indicates whether to use SPMD (true) or MPMD (false) partitioning when
    num_partitions > 1 and XLA is requested to partition the input program.
    """
    use_auto_spmd_partitioning: builtins.bool
    """Whether to automatically generate XLA shardings for SPMD partitioner."""
    deduplicate_hlo: builtins.bool
    """Whether HLOs should be deduplicated."""
    @property
    def device_assignment(self) -> tensorflow.compiler.xla.xla_data_pb2.DeviceAssignmentProto:
        """If set, this specifies a static device assignment for the computation.
        Otherwise, the computation will be compiled generically and can be run with
        any device assignment compatible with the computation's replica and
        partition counts.
        """
    alias_passthrough_params: builtins.bool
    """Whether input and output buffers are aliased if the associated parameter is
    passed-through XLA modules without being changed.
    """
    run_backend_only: builtins.bool
    """By default, XLA builds an executable by invoking standard compilation, i.e.
    running Compiler::Compile, or both Compiler::RunHloPasses and
    Compiler::RunBackend. When run_backend_only is set to true, XLA builds an
    executable by invoking only RunBackend and skip invoking RunHloPasses,
    which can be used to compile post-optimizations HLO modules.
    """
    allow_spmd_sharding_propagation_to_output: builtins.bool
    """Allows sharding propagation to propagate to the outputs. This changes the
    output shape of the computation (which is undesirable), but it can be used
    to allow to run partial compilation to determine what would be the output
    sharding of a computation if XLA would be allowed to propagate the sharding
    which can be used by higher level framework as a way to query intermediate
    sharding of operations when multiple computation would be chained and
    merged together.
    """
    def __init__(
        self,
        *,
        device_ordinal: builtins.int = ...,
        result_layout: tensorflow.compiler.xla.xla_data_pb2.ShapeProto | None = ...,
        debug_options: tensorflow.compiler.xla.xla_pb2.DebugOptions | None = ...,
        num_replicas: builtins.int = ...,
        num_partitions: builtins.int = ...,
        use_spmd_partitioning: builtins.bool = ...,
        use_auto_spmd_partitioning: builtins.bool = ...,
        deduplicate_hlo: builtins.bool = ...,
        device_assignment: tensorflow.compiler.xla.xla_data_pb2.DeviceAssignmentProto | None = ...,
        alias_passthrough_params: builtins.bool = ...,
        run_backend_only: builtins.bool = ...,
        allow_spmd_sharding_propagation_to_output: builtins.bool = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["debug_options", b"debug_options", "device_assignment", b"device_assignment", "result_layout", b"result_layout"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["alias_passthrough_params", b"alias_passthrough_params", "allow_spmd_sharding_propagation_to_output", b"allow_spmd_sharding_propagation_to_output", "debug_options", b"debug_options", "deduplicate_hlo", b"deduplicate_hlo", "device_assignment", b"device_assignment", "device_ordinal", b"device_ordinal", "num_partitions", b"num_partitions", "num_replicas", b"num_replicas", "result_layout", b"result_layout", "run_backend_only", b"run_backend_only", "use_auto_spmd_partitioning", b"use_auto_spmd_partitioning", "use_spmd_partitioning", b"use_spmd_partitioning"]) -> None: ...

global___ExecutableBuildOptionsProto = ExecutableBuildOptionsProto

@typing_extensions.final
class CompileOptionsProto(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ARGUMENT_LAYOUTS_FIELD_NUMBER: builtins.int
    PARAMETER_IS_TUPLED_ARGUMENTS_FIELD_NUMBER: builtins.int
    EXECUTABLE_BUILD_OPTIONS_FIELD_NUMBER: builtins.int
    COMPILE_PORTABLE_EXECUTABLE_FIELD_NUMBER: builtins.int
    PROFILE_VERSION_FIELD_NUMBER: builtins.int
    SERIALIZED_MULTI_SLICE_CONFIG_FIELD_NUMBER: builtins.int
    @property
    def argument_layouts(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[tensorflow.compiler.xla.xla_data_pb2.ShapeProto]:
        """Refer CompileOptions for documentation of fields."""
    parameter_is_tupled_arguments: builtins.bool
    @property
    def executable_build_options(self) -> global___ExecutableBuildOptionsProto: ...
    compile_portable_executable: builtins.bool
    profile_version: builtins.int
    serialized_multi_slice_config: builtins.bytes
    def __init__(
        self,
        *,
        argument_layouts: collections.abc.Iterable[tensorflow.compiler.xla.xla_data_pb2.ShapeProto] | None = ...,
        parameter_is_tupled_arguments: builtins.bool = ...,
        executable_build_options: global___ExecutableBuildOptionsProto | None = ...,
        compile_portable_executable: builtins.bool = ...,
        profile_version: builtins.int = ...,
        serialized_multi_slice_config: builtins.bytes = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["executable_build_options", b"executable_build_options"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["argument_layouts", b"argument_layouts", "compile_portable_executable", b"compile_portable_executable", "executable_build_options", b"executable_build_options", "parameter_is_tupled_arguments", b"parameter_is_tupled_arguments", "profile_version", b"profile_version", "serialized_multi_slice_config", b"serialized_multi_slice_config"]) -> None: ...

global___CompileOptionsProto = CompileOptionsProto
