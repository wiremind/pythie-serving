"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import sys
import tensorflow.core.framework.tensor_shape_pb2
import tensorflow.core.framework.types_pb2

if sys.version_info >= (3, 8):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing_extensions.final
class TensorId(google.protobuf.message.Message):
    """TensorId identifies a tensor in a TensorFlow graph, by specifying the output
    index of a particular node in the graph.  If the output of the named node
    feeds into other node(s), this corresponds to one or more edges.  Otherwise
    it doesn't correspond to any existing edges at all, e.g. for output nodes.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NODE_NAME_FIELD_NUMBER: builtins.int
    OUTPUT_INDEX_FIELD_NUMBER: builtins.int
    node_name: builtins.str
    output_index: builtins.int
    def __init__(
        self,
        *,
        node_name: builtins.str = ...,
        output_index: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["node_name", b"node_name", "output_index", b"output_index"]) -> None: ...

global___TensorId = TensorId

@typing_extensions.final
class Feed(google.protobuf.message.Message):
    """Feed represents a single feed tensor in the graph, which corresponds to an
    input argument for the generated computation.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ID_FIELD_NUMBER: builtins.int
    SHAPE_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    @property
    def id(self) -> global___TensorId: ...
    @property
    def shape(self) -> tensorflow.core.framework.tensor_shape_pb2.TensorShapeProto: ...
    name: builtins.str
    """Optional name for generated code."""
    type: tensorflow.core.framework.types_pb2.DataType.ValueType
    """Optional data type. This is not normally required, as the graph itself
    contains this information. However, if the node being fed is an op that is
    not linked into the binary, then the type cannot be inferred from the node;
    in this case, the type should be set here.
    """
    def __init__(
        self,
        *,
        id: global___TensorId | None = ...,
        shape: tensorflow.core.framework.tensor_shape_pb2.TensorShapeProto | None = ...,
        name: builtins.str = ...,
        type: tensorflow.core.framework.types_pb2.DataType.ValueType = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["id", b"id", "shape", b"shape"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["id", b"id", "name", b"name", "shape", b"shape", "type", b"type"]) -> None: ...

global___Feed = Feed

@typing_extensions.final
class Fetch(google.protobuf.message.Message):
    """Fetch represents a single fetch tensor in the graph, which corresponds to an
    output argument for the generated computation.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ID_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    SHAPE_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    @property
    def id(self) -> global___TensorId: ...
    name: builtins.str
    """Optional name for generated code."""
    @property
    def shape(self) -> tensorflow.core.framework.tensor_shape_pb2.TensorShapeProto:
        """Optional shape and data type. If specified, may be used for validation."""
    type: tensorflow.core.framework.types_pb2.DataType.ValueType
    def __init__(
        self,
        *,
        id: global___TensorId | None = ...,
        name: builtins.str = ...,
        shape: tensorflow.core.framework.tensor_shape_pb2.TensorShapeProto | None = ...,
        type: tensorflow.core.framework.types_pb2.DataType.ValueType = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["id", b"id", "shape", b"shape"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["id", b"id", "name", b"name", "shape", b"shape", "type", b"type"]) -> None: ...

global___Fetch = Fetch

@typing_extensions.final
class Variable(google.protobuf.message.Message):
    """Variable represents a resource variable with the given name, shape and type."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NODE_NAME_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    SHAPE_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    READONLY_FIELD_NUMBER: builtins.int
    node_name: builtins.str
    name: builtins.str
    """Optional name for generated code. If empty, node_name will be used."""
    @property
    def shape(self) -> tensorflow.core.framework.tensor_shape_pb2.TensorShapeProto: ...
    type: tensorflow.core.framework.types_pb2.DataType.ValueType
    readonly: builtins.bool
    """Flag for variables that are never assigned. Assignments to a read-only
    variable or unassigned variables that are not read-only are invalid.
    """
    def __init__(
        self,
        *,
        node_name: builtins.str = ...,
        name: builtins.str = ...,
        shape: tensorflow.core.framework.tensor_shape_pb2.TensorShapeProto | None = ...,
        type: tensorflow.core.framework.types_pb2.DataType.ValueType = ...,
        readonly: builtins.bool = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["shape", b"shape"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["name", b"name", "node_name", b"node_name", "readonly", b"readonly", "shape", b"shape", "type", b"type"]) -> None: ...

global___Variable = Variable

@typing_extensions.final
class Config(google.protobuf.message.Message):
    """Config represents configuration information for tf2xla conversion."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    FEED_FIELD_NUMBER: builtins.int
    FETCH_FIELD_NUMBER: builtins.int
    VARIABLE_FIELD_NUMBER: builtins.int
    @property
    def feed(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Feed]:
        """Each feed is a positional input argument for the generated computation.
        The order of each entry matches the order of each input argument.
        """
    @property
    def fetch(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Fetch]:
        """Each fetch is a positional output argument for the generated computation.
        The order of each entry matches the order of each output argument.
        """
    @property
    def variable(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Variable]:
        """Each variable is a named input and output of the generated computation."""
    def __init__(
        self,
        *,
        feed: collections.abc.Iterable[global___Feed] | None = ...,
        fetch: collections.abc.Iterable[global___Fetch] | None = ...,
        variable: collections.abc.Iterable[global___Variable] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["feed", b"feed", "fetch", b"fetch", "variable", b"variable"]) -> None: ...

global___Config = Config
